<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>reStrike VTA - Olympic Scoreboard Overlay</title>
    <link rel="stylesheet" href="/assets/fonts/fonts.css">
    <link rel="stylesheet" href="/overlays/olympic/scoreboard.css">
</head>
<body>
    <div id="connection-status" class="connection-status"></div>
    <div id="debug-panel" class="debug-panel">
        <div>PSS Status: <span id="pss-status">Disconnected</span></div>
        <div>Last Update: <span id="last-update">Never</span></div>
        <div>Blue Player: <span id="debug-blue">-</span></div>
        <div>Red Player: <span id="debug-red">-</span></div>
        <div>Blue Score: <span id="debug-blue-score">0</span></div>
        <div>Red Score: <span id="debug-red-score">0</span></div>
    </div>

    <div id="scoreboard-container">
        <object id="scoreboard-svg" data="/assets/scoreboard/olympic/olympic_scoreboard.svg" type="image/svg+xml">
            <div class="scoreboard-fallback">Scoreboard Overlay Loading...</div>
        </object>
    </div>

    <script src="/assets/scoreboard/scoreboard-name-utils.js"></script>
    <script src="/assets/scoreboard/scoreboard-font-injector.js"></script>
    <script src="/assets/scoreboard/scoreboard-utils.js"></script>

    <script>
        let scoreboardInstance = null;
        let nameManager = null;
        // Simple event caches to avoid losing early events before SVG loads
        let cacheAthletes = null;
        let cacheWarnings = null;
        let cacheMatchConfig = null;
        let cacheScores = null;
        let isConnected = false;
        let lastUpdateTime = null;
        let roundDuration = 120;
        const DEBUG_MODE = false;

        function updateConnectionStatus(connected) {
            isConnected = connected;
            const statusElement = document.getElementById('connection-status');
            const pssStatusElement = document.getElementById('pss-status');
            if (connected) { statusElement.classList.add('connected'); pssStatusElement.textContent = 'Connected'; pssStatusElement.style.color = '#10b981'; }
            else { statusElement.classList.remove('connected'); pssStatusElement.textContent = 'Disconnected'; pssStatusElement.style.color = '#ef4444'; }
        }

        function updateDebugInfo() {
            const lastUpdateElement = document.getElementById('last-update');
            if (lastUpdateTime) { lastUpdateElement.textContent = lastUpdateTime.toLocaleTimeString(); }
        }

        function initializeScoreboard() {
            const svgObject = document.getElementById('scoreboard-svg');
            if (!svgObject) { console.error('❌ SVG object not found'); return; }
            const svgDoc = svgObject.contentDocument || svgObject.contentWindow?.document;
            if (svgDoc && svgDoc.querySelector('svg')) {
                if (typeof ScoreboardOverlay === 'undefined' || typeof ScoreboardNameManager === 'undefined') { setTimeout(initializeScoreboard, 1000); return; }
                try {
                    scoreboardInstance = new ScoreboardOverlay(svgDoc.querySelector('svg'));
                    nameManager = new ScoreboardNameManager();
                    updateConnectionStatus(false); updateDebugInfo();
                    if (DEBUG_MODE) { document.getElementById('debug-panel').classList.add('show'); }
                    // Apply cached events if any
                    if (cacheMatchConfig) {
                        const d = cacheMatchConfig; roundDuration = d.round_duration ? parseInt(d.round_duration) : roundDuration;
                        if (d.weight || d.division || d.category) scoreboardInstance.updateMatchInfo(d.weight, d.division, d.category);
                        if (d.number) scoreboardInstance.updateMatchNumber(d.number);
                        scoreboardInstance.setInjuryTime(1,0); scoreboardInstance.setInjuryVisible(false);
                        scoreboardInstance.updateAthleteWarnings('blue', 0); scoreboardInstance.updateAthleteWarnings('red', 0);
                    }
                    if (cacheAthletes) {
                        if (cacheAthletes.a1) { scoreboardInstance.updateAthleteName('blue', cacheAthletes.a1); scoreboardInstance.updateAthleteFlag('blue', cacheAthletes.a1); }
                        if (cacheAthletes.a2) { scoreboardInstance.updateAthleteName('red', cacheAthletes.a2); scoreboardInstance.updateAthleteFlag('red', cacheAthletes.a2); }
                    }
                    if (cacheScores) {
                        scoreboardInstance.updateAthleteScore('blue', cacheScores.b);
                        scoreboardInstance.updateAthleteScore('red', cacheScores.r);
                    }
                    if (cacheWarnings) {
                        scoreboardInstance.updateAthleteWarnings('blue', cacheWarnings.b);
                        scoreboardInstance.updateAthleteWarnings('red', cacheWarnings.r);
                        try {
                            const e1 = scoreboardInstance.svg.getElementById('player1Fouls'); const e2 = scoreboardInstance.svg.getElementById('player2Fouls');
                            if (e1) { const t=e1.querySelector('tspan'); if (t) t.textContent=String(cacheWarnings.b); else e1.textContent=String(cacheWarnings.b); }
                            if (e2) { const t=e2.querySelector('tspan'); if (t) t.textContent=String(cacheWarnings.r); else e2.textContent=String(cacheWarnings.r); }
                        } catch(_) {}
                    }
                } catch (error) { console.error('❌ Error initializing scoreboard:', error); setTimeout(initializeScoreboard, 1000); }
            } else { setTimeout(initializeScoreboard, 1000); }
        }

        function handlePssEvent(event) {
            lastUpdateTime = new Date();
            if (!scoreboardInstance) {
                // Populate caches and return until initialized
                if (event && event.type) {
                    const t = String(event.type).toLowerCase();
                    if (t==='athletes') {
                        const a1 = event.athlete1_country || event.country1 || event.athlete1?.country || event.athlete1?.code || null;
                        const a2 = event.athlete2_country || event.country2 || event.athlete2?.country || event.athlete2?.code || null;
                        cacheAthletes = { a1, a2 };
                    } else if (t==='warnings' || t==='gamjeom' || t==='gam_jeom' || t==='wg') {
                        if (event.athlete1_warnings!=null || event.athlete2_warnings!=null) {
                            cacheWarnings = { b: parseInt(event.athlete1_warnings||0), r: parseInt(event.athlete2_warnings||0) };
                        } else if (event.raw_data && /wg1;(\d+);wg2;(\d+)/i.test(event.raw_data)) {
                            const m = event.raw_data.match(/wg1;(\d+);wg2;(\d+)/i); cacheWarnings = { b: parseInt(m[1]), r: parseInt(m[2]) };
                        }
                    } else if (t==='match_config') {
                        const d = event.raw_data ? JSON.parse(event.raw_data) : (event.structured_data || event);
                        cacheMatchConfig = d;
                    } else if (t==='current_scores') {
                        const sc = event.raw_data ? JSON.parse(event.raw_data) : event; cacheScores = { b: sc.athlete1_score ?? sc?.athlete1?.score ?? 0, r: sc.athlete2_score ?? sc?.athlete2?.score ?? 0 };
                    }
                }
                return;
            }
            try {
                updateConnectionStatus(true);
                const typeLower = (event && event.type ? String(event.type).toLowerCase() : '');
                switch (typeLower) {
                    case 'athletes':
                        // Parse IOC codes strictly from raw JSON string
                        let a1c = null, a2c = null;
                        if (typeof event.raw_data === 'string' && event.raw_data.trim().startsWith('{')) {
                            try { const rd = JSON.parse(event.raw_data); a1c = rd?.athlete1?.country || null; a2c = rd?.athlete2?.country || null; } catch(_) {}
                        }
                        if (a1c) {
                            scoreboardInstance.updateAthleteName('blue', a1c);
                            scoreboardInstance.updateAthleteFlag('blue', a1c);
                            try {
                                const n1 = scoreboardInstance.svg.getElementById('player1Name'); if (n1) n1.textContent = a1c.toUpperCase();
                                const f1 = scoreboardInstance.svg.getElementById('player1Flag'); if (f1){ let img=f1.querySelector('image'); if(!img){ img=document.createElementNS('http://www.w3.org/2000/svg','image'); const bb=f1.getBBox(); img.setAttribute('x',bb.x); img.setAttribute('y',bb.y); img.setAttribute('width',bb.width); img.setAttribute('height',bb.height); img.setAttribute('preserveAspectRatio','xMidYMid meet'); f1.appendChild(img);} img.setAttribute('href', `/assets/flags/svg/${a1c.toUpperCase()}.svg`); img.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href', `/assets/flags/svg/${a1c.toUpperCase()}.svg`);} 
                            } catch(_) {}
                            document.getElementById('debug-blue').textContent = a1c;
                        }
                        if (a2c) {
                            scoreboardInstance.updateAthleteName('red', a2c);
                            scoreboardInstance.updateAthleteFlag('red', a2c);
                            try {
                                const n2 = scoreboardInstance.svg.getElementById('player2Name'); if (n2) n2.textContent = a2c.toUpperCase();
                                const f2 = scoreboardInstance.svg.getElementById('player2Flag'); if (f2){ let img=f2.querySelector('image'); if(!img){ img=document.createElementNS('http://www.w3.org/2000/svg','image'); const bb=f2.getBBox(); img.setAttribute('x',bb.x); img.setAttribute('y',bb.y); img.setAttribute('width',bb.width); img.setAttribute('height',bb.height); img.setAttribute('preserveAspectRatio','xMidYMid meet'); f2.appendChild(img);} img.setAttribute('href', `/assets/flags/svg/${a2c.toUpperCase()}.svg`); img.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href', `/assets/flags/svg/${a2c.toUpperCase()}.svg`);} 
                            } catch(_) {}
                            document.getElementById('debug-red').textContent = a2c;
                        }
                        break;
                    case 'match_config':
                        const data = event.raw_data ? JSON.parse(event.raw_data) : (event.structured_data || event);
                        if (data.round_duration !== undefined && data.round_duration !== null) { roundDuration = parseInt(data.round_duration); }
                        if (data.weight || data.division || data.category) { scoreboardInstance.updateMatchInfo(data.weight, data.division, data.category); }
                        if (data.number) { scoreboardInstance.updateMatchNumber(data.number); }
                        // Injury initial state: hidden with 1:00 countdown baseline (visual only until event arrives)
                        scoreboardInstance.setInjuryTime(1, 0);
                        scoreboardInstance.setInjuryVisible(false);
                        // Initialize fouls to zero on match load
                        scoreboardInstance.updateAthleteWarnings('blue', 0);
                        scoreboardInstance.updateAthleteWarnings('red', 0);
                        try {
                            const e1 = scoreboardInstance.svg.getElementById('player1Fouls');
                            const e2 = scoreboardInstance.svg.getElementById('player2Fouls');
                            if (e1) { const t=e1.querySelector('tspan'); if (t) t.textContent='0'; else e1.textContent='0'; e1.style.display='block'; }
                            if (e2) { const t=e2.querySelector('tspan'); if (t) t.textContent='0'; else e2.textContent='0'; e2.style.display='block'; }
                            const g1 = scoreboardInstance.svg.getElementById('player1_x5F_blue'); if (g1){ const bg=g1.querySelector('rect.cls-36'); if (bg) bg.style.display='block'; }
                            const g2 = scoreboardInstance.svg.getElementById('player2_x5F_red'); if (g2){ const bg=g2.querySelector('rect.cls-36'); if (bg) bg.style.display='block'; }
                        } catch(_) {}
                        break;
                    case 'current_scores':
                        const sc = event.raw_data ? JSON.parse(event.raw_data) : event;
                        const blue = sc.athlete1_score ?? sc?.athlete1?.score ?? 0;
                        const red = sc.athlete2_score ?? sc?.athlete2?.score ?? 0;
                        scoreboardInstance.updateAthleteScore('blue', blue);
                        scoreboardInstance.updateAthleteScore('red', red);
                        document.getElementById('debug-blue-score').textContent = blue;
                        document.getElementById('debug-red-score').textContent = red;
                        break;
                    case 'warnings':
                    case 'gamjeom':
                    case 'gam_jeom':
                    case 'wg':
                        // 1) Structured numeric fields
                        if (event.athlete1_warnings !== undefined || event.athlete2_warnings !== undefined) {
                            if (event.athlete1_warnings !== undefined) scoreboardInstance.updateAthleteWarnings('blue', parseInt(event.athlete1_warnings));
                            if (event.athlete2_warnings !== undefined) scoreboardInstance.updateAthleteWarnings('red', parseInt(event.athlete2_warnings));
                            // Fallback: force update by IDs if needed
                            try {
                                const e1 = scoreboardInstance.svg.getElementById('player1Fouls');
                                const e2 = scoreboardInstance.svg.getElementById('player2Fouls');
                                if (e1) { const t=e1.querySelector('tspan'); if (t) t.textContent=String(parseInt(event.athlete1_warnings)); else e1.textContent=String(parseInt(event.athlete1_warnings)); e1.style.display='block'; }
                                if (e2) { const t=e2.querySelector('tspan'); if (t) t.textContent=String(parseInt(event.athlete2_warnings)); else e2.textContent=String(parseInt(event.athlete2_warnings)); e2.style.display='block'; }
                                const g1 = scoreboardInstance.svg.getElementById('player1_x5F_blue'); if (g1){ const bg=g1.querySelector('rect.cls-36'); if (bg) bg.style.display='block'; }
                                const g2 = scoreboardInstance.svg.getElementById('player2_x5F_red'); if (g2){ const bg=g2.querySelector('rect.cls-36'); if (bg) bg.style.display='block'; }
                            } catch(_) {}
                        } else if (event.raw_data && typeof event.raw_data === 'string') {
                            // 2) Raw string packet format wg1;X;wg2;Y
                            let parsedB = null, parsedR = null;
                            const m = event.raw_data.match(/wg1;(\d+);wg2;(\d+)/i);
                            if (m) { parsedB = parseInt(m[1]); parsedR = parseInt(m[2]); }
                            // 3) Raw JSON string
                            if ((parsedB===null || parsedR===null) && event.raw_data.trim().startsWith('{')) {
                                try {
                                    const rd = JSON.parse(event.raw_data);
                                    parsedB = (rd.athlete1_warnings ?? rd.a1 ?? rd.wg1 ?? rd.athlete1 ?? null);
                                    parsedR = (rd.athlete2_warnings ?? rd.a2 ?? rd.wg2 ?? rd.athlete2 ?? null);
                                    if (typeof parsedB === 'string') parsedB = parseInt(parsedB);
                                    if (typeof parsedR === 'string') parsedR = parseInt(parsedR);
                                } catch(_) {}
                            }
                            // 4) Description text
                            if ((parsedB===null || parsedR===null) && event.description) {
                                const md = String(event.description).match(/Athlete1:\s*(\d+).*Athlete2:\s*(\d+)/i);
                                if (md) { parsedB = parseInt(md[1]); parsedR = parseInt(md[2]); }
                            }
                            if (parsedB!=null && parsedR!=null) {
                                scoreboardInstance.updateAthleteWarnings('blue', parsedB);
                                scoreboardInstance.updateAthleteWarnings('red', parsedR);
                                try {
                                    const e1 = scoreboardInstance.svg.getElementById('player1Fouls');
                                    const e2 = scoreboardInstance.svg.getElementById('player2Fouls');
                                    if (e1) { const t=e1.querySelector('tspan'); if (t) t.textContent=String(parsedB); else e1.textContent=String(parsedB); e1.style.display='block'; }
                                    if (e2) { const t=e2.querySelector('tspan'); if (t) t.textContent=String(parsedR); else e2.textContent=String(parsedR); e2.style.display='block'; }
                                } catch(_) {}
                            }
                        }
                        break;
                    case 'injury':
                    case 'injury_time':
                    case 'ij':
                        {
                            const t = event.time || (event.raw_data && String(event.raw_data).split(';')[1]) || null;
                            const raw = event.raw_data ? String(event.raw_data).toLowerCase() : '';
                            const action = (event.action || (raw.includes('show') ? 'show' : (raw.includes('hide') ? 'hide' : '')) || '').toLowerCase();
                            if (t && t.includes(':')) {
                                const parts = t.split(':');
                                const minutes = parseInt(parts[0]) || 0;
                                const seconds = parseInt(parts[1]) || 0;
                                scoreboardInstance.setInjuryTime(minutes, seconds);
                            }
                            if (action === 'show') scoreboardInstance.setInjuryVisible(true);
                            else if (action === 'hide') scoreboardInstance.setInjuryVisible(false);
                            else if (t) scoreboardInstance.setInjuryVisible(true);
                        }
                        break;
                    case 'winner_rounds':
                    case 'winnerrounds':
                        // Compute round wins from per-round winners if provided; keep zero by default
                        let r1 = event.round1_winner||0, r2 = event.round2_winner||0, r3 = event.round3_winner||0;
                        if (event.raw_data && typeof event.raw_data === 'string' && event.raw_data.trim().startsWith('{')) {
                            try { const rd = JSON.parse(event.raw_data); r1 = rd.round1_winner ?? r1; r2 = rd.round2_winner ?? r2; r3 = rd.round3_winner ?? r3; } catch(_) {}
                        }
                        const blueWins = [r1,r2,r3].filter(v=>v===1).length;
                        const redWins = [r1,r2,r3].filter(v=>v===2).length;
                        scoreboardInstance.updateAthleteRounds('blue', blueWins);
                        scoreboardInstance.updateAthleteRounds('red', redWins);
                        break;
                    case 'clock':
                        if (event.time) {
                            let minutes = 0, seconds = 0;
                            if (event.time.includes(':')) { const parts = event.time.split(':'); minutes = parseInt(parts[0])||0; seconds = parseInt(parts[1])||0; }
                            else { seconds = parseInt(event.time)||0; }
                            scoreboardInstance.updateTimer(minutes, seconds);
                        }
                        break;
                    case 'round':
                        const roundNumber = event.current_round ?? event.round ?? null;
                        if (roundNumber !== null) {
                            scoreboardInstance.updateRound(roundNumber);
                            const m = Math.floor(roundDuration / 60), s = roundDuration % 60;
                            scoreboardInstance.updateTimer(m, s);
                            // Reset current scores and warnings on new round start
                            scoreboardInstance.updateAthleteScore('blue', 0);
                            scoreboardInstance.updateAthleteScore('red', 0);
                            scoreboardInstance.updateAthleteWarnings('blue', 0);
                            scoreboardInstance.updateAthleteWarnings('red', 0);
                            try {
                                const e1 = scoreboardInstance.svg.getElementById('player1Fouls');
                                const e2 = scoreboardInstance.svg.getElementById('player2Fouls');
                                if (e1) { const t=e1.querySelector('tspan'); if (t) t.textContent='0'; else e1.textContent='0'; }
                                if (e2) { const t=e2.querySelector('tspan'); if (t) t.textContent='0'; else e2.textContent='0'; }
                            } catch(_) {}
                        }
                        break;
                    default:
                        // Try to parse raw strings that encode warnings or injury
                        if (event && event.raw_data && typeof event.raw_data === 'string') {
                            const raw = event.raw_data.toLowerCase();
                            const mw = raw.match(/wg1;(\d+);wg2;(\d+)/);
                            if (mw) {
                                scoreboardInstance.updateAthleteWarnings('blue', parseInt(mw[1]));
                                scoreboardInstance.updateAthleteWarnings('red', parseInt(mw[2]));
                                break;
                            }
                            const mi = raw.match(/ij[012];(\d+:\d+)(?:;(show|hide|reset))?/);
                            if (mi) {
                                const parts = mi[1].split(':');
                                const minutes = parseInt(parts[0])||0;
                                const seconds = parseInt(parts[1])||0;
                                scoreboardInstance.setInjuryTime(minutes, seconds);
                                const act = mi[2]||'';
                                if (act==='show') scoreboardInstance.setInjuryVisible(true);
                                else if (act==='hide') scoreboardInstance.setInjuryVisible(false);
                                else scoreboardInstance.setInjuryVisible(true);
                                break;
                            }
                        }
                        break;
                }
                updateDebugInfo();
            } catch (error) { console.error('❌ Error handling PSS event:', error); }
        }

        let websocket = null; let reconnectAttempts = 0; const maxReconnectAttempts = 5; const reconnectDelay = 2000;
        function setupWebSocketConnection() {
            try {
                const currentHost = window.location.hostname; const wsHost = (currentHost === 'localhost' || currentHost === '127.0.0.1') ? '127.0.0.1' : currentHost; const wsUrl = `ws://${wsHost}:3001`;
                websocket = new WebSocket(wsUrl);
                websocket.onopen = function() { updateConnectionStatus(true); reconnectAttempts = 0; setInterval(()=>{ if(websocket.readyState===WebSocket.OPEN){ websocket.send('ping'); } }, 30000); };
                websocket.onmessage = function(event) { try { const data = JSON.parse(event.data); if (data.type === 'pss_event') { handlePssEvent(data.data); } } catch(e) { console.error('❌ WS parse error:', e); } };
                websocket.onclose = function() { updateConnectionStatus(false); if (reconnectAttempts < maxReconnectAttempts) { reconnectAttempts++; setTimeout(setupWebSocketConnection, reconnectDelay); } };
                websocket.onerror = function() { updateConnectionStatus(false); };
            } catch (error) { updateConnectionStatus(false); }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const svgObject = document.getElementById('scoreboard-svg');
            if (window.ScoreboardFontInjector) { window.ScoreboardFontInjector.initForObject('#scoreboard-svg'); }
            svgObject.addEventListener('load', initializeScoreboard);
            setupWebSocketConnection();
            if (svgObject.contentDocument) { initializeScoreboard(); }
        });

        window.ScoreboardOverlayManager = { handlePssEvent, updateConnectionStatus, scoreboardInstance: () => scoreboardInstance, nameManager: () => nameManager };
    </script>
</body>
</html>


