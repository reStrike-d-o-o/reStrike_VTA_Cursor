<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>reStrike VTA - Scoreboard Overlay</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: transparent;
            font-family: Arial, sans-serif;
        }
        
        #scoreboard-container {
            width: 1920px;
            height: 1080px;
            position: relative;
        }
        
        #scoreboard-svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Animation classes for score updates */
        .score-update {
            animation: scorePulse 0.5s ease-in-out;
        }
        
        @keyframes scorePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Connection status indicator */
        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            border: 2px solid #ffffff;
            z-index: 1000;
        }
        
        .connection-status.connected {
            background: #10b981;
        }
        
        /* Debug panel (hidden by default) */
        .debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
        
        .debug-panel.show {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Connection Status Indicator -->
    <div id="connection-status" class="connection-status"></div>
    
    <!-- Debug Panel -->
    <div id="debug-panel" class="debug-panel">
        <div>PSS Status: <span id="pss-status">Disconnected</span></div>
        <div>Last Update: <span id="last-update">Never</span></div>
        <div>Blue Player: <span id="debug-blue">-</span></div>
        <div>Red Player: <span id="debug-red">-</span></div>
        <div>Blue Score: <span id="debug-blue-score">0</span></div>
        <div>Red Score: <span id="debug-red-score">0</span></div>
    </div>
    
    <!-- Scoreboard Container -->
    <div id="scoreboard-container">
        <object id="scoreboard-svg" data="assets/scoreboard/scoreboard-overlay.svg" type="image/svg+xml">
            <!-- Fallback content if SVG fails to load -->
            <div style="width: 1920px; height: 1080px; background: #000; color: white; display: flex; align-items: center; justify-content: center; font-size: 48px;">
                Scoreboard Overlay Loading...
            </div>
        </object>
    </div>

    <!-- JavaScript Utilities -->
    <script src="assets/scoreboard/scoreboard-name-utils.js"></script>
    <script src="assets/scoreboard/scoreboard-utils.js"></script>
    
    <!-- PSS Event Integration Script -->
    <script>
        // Global variables
        let scoreboardInstance = null;
        let nameManager = null;
        let isConnected = false;
        let lastUpdateTime = null;
        
        // Debug mode (set to true to show debug panel)
        const DEBUG_MODE = false;
        
        // Initialize the scoreboard when SVG loads
        function initializeScoreboard() {
            const svgObject = document.getElementById('scoreboard-svg');
            
            if (!svgObject) {
                console.error('‚ùå SVG object not found');
                return;
            }
            
            console.log('üîç Checking SVG object:', svgObject);
            console.log('üîç SVG object readyState:', svgObject.readyState);
            
            const svgDoc = svgObject.contentDocument || svgObject.contentWindow?.document;
            
            console.log('üîç SVG document:', svgDoc);
            
            if (svgDoc && svgDoc.querySelector('svg')) {
                console.log('üéØ Scoreboard SVG loaded, initializing...');
                
                // Check if ScoreboardOverlay class is available
                if (typeof ScoreboardOverlay === 'undefined') {
                    console.error('‚ùå ScoreboardOverlay class not found');
                    console.log('üîç Available window objects:', Object.keys(window).filter(key => key.includes('Scoreboard')));
                    setTimeout(initializeScoreboard, 1000); // Retry after 1 second
                    return;
                }
                
                // Check if ScoreboardNameManager class is available
                if (typeof ScoreboardNameManager === 'undefined') {
                    console.error('‚ùå ScoreboardNameManager class not found');
                    console.log('üîç Available window objects:', Object.keys(window).filter(key => key.includes('Name')));
                    setTimeout(initializeScoreboard, 1000); // Retry after 1 second
                    return;
                }
                
                try {
                    // Initialize scoreboard utilities
                    scoreboardInstance = new ScoreboardOverlay(svgDoc.querySelector('svg'));
                    nameManager = new ScoreboardNameManager();
                    
                    // Set initial state
                    updateConnectionStatus(false);
                    updateDebugInfo();
                    
                    // Show debug panel if in debug mode
                    if (DEBUG_MODE) {
                        document.getElementById('debug-panel').classList.add('show');
                    }
                    
                    console.log('‚úÖ Scoreboard initialized successfully');
                } catch (error) {
                    console.error('‚ùå Error initializing scoreboard:', error);
                    setTimeout(initializeScoreboard, 1000); // Retry after 1 second
                }
            } else {
                console.error('‚ùå Failed to load SVG document');
                console.log('üîç SVG object contentDocument:', svgObject.contentDocument);
                console.log('üîç SVG object contentWindow:', svgObject.contentWindow);
                setTimeout(initializeScoreboard, 1000); // Retry after 1 second
            }
        }
        
        // Update connection status indicator
        function updateConnectionStatus(connected) {
            isConnected = connected;
            const statusElement = document.getElementById('connection-status');
            const pssStatusElement = document.getElementById('pss-status');
            
            if (connected) {
                statusElement.classList.add('connected');
                pssStatusElement.textContent = 'Connected';
                pssStatusElement.style.color = '#10b981';
            } else {
                statusElement.classList.remove('connected');
                pssStatusElement.textContent = 'Disconnected';
                pssStatusElement.style.color = '#ef4444';
            }
        }
        
        // Update debug information
        function updateDebugInfo() {
            const lastUpdateElement = document.getElementById('last-update');
            if (lastUpdateTime) {
                lastUpdateElement.textContent = lastUpdateTime.toLocaleTimeString();
            }
        }
        
        // Handle PSS events from Tauri
        function handlePssEvent(event) {
            console.log('üì° Received PSS event:', event);
            lastUpdateTime = new Date();
            
            if (!scoreboardInstance) {
                console.warn('‚ö†Ô∏è Scoreboard not initialized, ignoring event');
                return;
            }
            
            try {
                // Update connection status
                updateConnectionStatus(true);
                
                // Handle different event types
                switch (event.type) {
                    case 'athletes':
                        handleAthletesEvent(event);
                        break;
                    case 'match_config':
                        handleMatchConfigEvent(event);
                        break;
                    case 'current_scores':
                        handleScoresEvent(event);
                        break;
                    case 'fight_loaded':
                        handleFightLoadedEvent(event);
                        break;
                    case 'warnings':
                        handleWarningsEvent(event);
                        break;
                    case 'winner_rounds':
                        handleWinnerRoundsEvent(event);
                        break;
                    case 'clock':
                        handleClockEvent(event);
                        break;
                    case 'round':
                        handleRoundEvent(event);
                        break;
                    case 'fight_ready':
                        handleFightReadyEvent(event);
                        break;
                    case 'raw':
                        handleRawEvent(event);
                        break;
                    default:
                        console.log('üìù Unhandled event type:', event.type);
                }
                
                updateDebugInfo();
                
            } catch (error) {
                console.error('‚ùå Error handling PSS event:', error);
            }
        }
        
        // Handle athletes event
        function handleAthletesEvent(event) {
            console.log('üë• Updating athletes:', event);
            
            // Update player names - athlete1 maps to player1 (blue), athlete2 maps to player2 (red)
            if (event.athlete1_long) {
                scoreboardInstance.updatePlayerName('blue', event.athlete1_long);
                document.getElementById('debug-blue').textContent = event.athlete1_long;
            }
            
            if (event.athlete2_long) {
                scoreboardInstance.updatePlayerName('red', event.athlete2_long);
                document.getElementById('debug-red').textContent = event.athlete2_long;
            }
            
            // Update countries - use iocCode if available, otherwise use country code
            if (event.athlete1_country) {
                const countryCode = event.athlete1_iocCode || event.athlete1_country;
                scoreboardInstance.updateCountry('blue', countryCode);
            }
            
            if (event.athlete2_country) {
                const countryCode = event.athlete2_iocCode || event.athlete2_country;
                scoreboardInstance.updateCountry('red', countryCode);
            }
        }
        
        // Handle match config event
        function handleMatchConfigEvent(event) {
            console.log('üèÜ Updating match config:', event);
            
            if (event.category) {
                scoreboardInstance.updateMatchCategory(event.category);
            }
            
            if (event.weight) {
                scoreboardInstance.updateMatchType(event.weight);
            }
            
            if (event.number) {
                // Update match number in SVG
                const matchNumberElement = scoreboardInstance.svg.getElementById('matchNumber');
                if (matchNumberElement) {
                    matchNumberElement.textContent = `#${event.number}`;
                }
            }
        }
        
        // Handle scores event
        function handleScoresEvent(event) {
            console.log('üìä Updating scores:', event);
            
            // athlete1 maps to blue (player1), athlete2 maps to red (player2)
            const blueScore = event.athlete1_score || 0;
            const redScore = event.athlete2_score || 0;
            
            scoreboardInstance.updateScore('blue', blueScore);
            scoreboardInstance.updateScore('red', redScore);
            
            // Update debug info
            document.getElementById('debug-blue-score').textContent = blueScore;
            document.getElementById('debug-red-score').textContent = redScore;
        }
        
        // Handle fight loaded event
        function handleFightLoadedEvent(event) {
            console.log('ü•ä Fight loaded event:', event);
            updateConnectionStatus(true);
        }
        
        // Handle warnings event
        function handleWarningsEvent(event) {
            console.log('‚ö†Ô∏è Warnings event:', event);
            
            // athlete1 maps to blue (player1), athlete2 maps to red (player2)
            if (event.athlete1_warnings !== undefined) {
                scoreboardInstance.updatePenalties('blue', null, event.athlete1_warnings);
            }
            
            if (event.athlete2_warnings !== undefined) {
                scoreboardInstance.updatePenalties('red', null, event.athlete2_warnings);
            }
        }
        
        // Handle winner rounds event
        function handleWinnerRoundsEvent(event) {
            console.log('üèÜ Winner rounds event:', event);
            
            // athlete1 (player1/blue) = winner 1, athlete2 (player2/red) = winner 2
            if (event.round1_winner !== undefined) {
                const blueWins = (event.round1_winner === 1 ? 1 : 0) + 
                                (event.round2_winner === 1 ? 1 : 0) + 
                                (event.round3_winner === 1 ? 1 : 0);
                const redWins = (event.round1_winner === 2 ? 1 : 0) + 
                               (event.round2_winner === 2 ? 1 : 0) + 
                               (event.round3_winner === 2 ? 1 : 0);
                
                scoreboardInstance.updateRoundWins('blue', blueWins);
                scoreboardInstance.updateRoundWins('red', redWins);
            }
        }
        
        // Handle clock event
        function handleClockEvent(event) {
            console.log('‚è∞ Clock event:', event);
            
            if (event.time) {
                // Parse time in format "m:ss" or "ss"
                let minutes = 0;
                let seconds = 0;
                
                if (event.time.includes(':')) {
                    const parts = event.time.split(':');
                    minutes = parseInt(parts[0]) || 0;
                    seconds = parseInt(parts[1]) || 0;
                } else {
                    seconds = parseInt(event.time) || 0;
                }
                
                scoreboardInstance.updateTimer(minutes, seconds);
            }
        }
        
        // Handle round event
        function handleRoundEvent(event) {
            console.log('üîÑ Round event:', event);
            
            if (event.current_round) {
                scoreboardInstance.updateRound(event.current_round);
            }
        }
        
        // Handle fight ready event
        function handleFightReadyEvent(event) {
            console.log('ü•ä Fight ready event:', event);
            updateConnectionStatus(true);
        }
        
        // Handle raw PSS events (for backward compatibility)
        function handleRawEvent(event) {
            console.log('üìù Raw PSS event:', event);
            
            if (!event.message) return;
            
            // Parse raw match config (mch;) lines
            if (event.message.startsWith('mch;')) {
                try {
                    const parts = event.message.split(';');
                    const matchConfig = {
                        number: parseInt(parts[1]) || 0,
                        category: parts[2] || '',
                        weight: parts[3]?.replace(/\s+/g, '') || '',
                        division: parts[10] || '',
                    };
                    
                    handleMatchConfigEvent(matchConfig);
                } catch (error) {
                    console.error('‚ùå Error parsing raw mch line:', error);
                }
            }
            
            // Parse warnings (wg1;wg2;) lines
            else if (event.message.includes('wg1;') && event.message.includes('wg2;')) {
                try {
                    const parts = event.message.split(';');
                    const warnings = {
                        athlete1_warnings: parseInt(parts[1]) || 0,
                        athlete2_warnings: parseInt(parts[3]) || 0,
                        type: 'warnings'
                    };
                    
                    handleWarningsEvent(warnings);
                } catch (error) {
                    console.error('‚ùå Error parsing raw warnings line:', error);
                }
            }
            
            // Parse winner rounds (wrd;) lines
            else if (event.message.startsWith('wrd;')) {
                try {
                    const parts = event.message.split(';');
                    const winnerRounds = {
                        round1_winner: parseInt(parts[2]) || 0,
                        round2_winner: parseInt(parts[4]) || 0,
                        round3_winner: parseInt(parts[6]) || 0,
                        type: 'winner_rounds'
                    };
                    
                    handleWinnerRoundsEvent(winnerRounds);
                } catch (error) {
                    console.error('‚ùå Error parsing raw winner rounds line:', error);
                }
            }
            
            // Parse clock (clk;) lines
            else if (event.message.startsWith('clk;')) {
                try {
                    const parts = event.message.split(';');
                    const clock = {
                        time: parts[1] || '0:00',
                        action: parts[2] || null,
                        type: 'clock'
                    };
                    
                    handleClockEvent(clock);
                } catch (error) {
                    console.error('‚ùå Error parsing raw clock line:', error);
                }
            }
            
            // Parse round (rnd;) lines
            else if (event.message.startsWith('rnd;')) {
                try {
                    const parts = event.message.split(';');
                    const round = {
                        current_round: parseInt(parts[1]) || 1,
                        type: 'round'
                    };
                    
                    handleRoundEvent(round);
                } catch (error) {
                    console.error('‚ùå Error parsing raw round line:', error);
                }
            }
            
            // Parse fight ready (rdy;) lines
            else if (event.message.startsWith('rdy;')) {
                try {
                    const parts = event.message.split(';');
                    const fightReady = {
                        status: parts[1] || 'FightReady',
                        type: 'fight_ready'
                    };
                    
                    handleFightReadyEvent(fightReady);
                } catch (error) {
                    console.error('‚ùå Error parsing raw fight ready line:', error);
                }
            }
            
            // Parse scores (sc1;sc2;) lines
            else if (event.message.includes('sc1;') && event.message.includes('sc2;')) {
                try {
                    const parts = event.message.split(';');
                    const scores = {
                        athlete1_score: parseInt(parts[1]) || 0,
                        athlete2_score: parseInt(parts[3]) || 0,
                        type: 'current_scores'
                    };
                    
                    handleScoresEvent(scores);
                } catch (error) {
                    console.error('‚ùå Error parsing raw scores line:', error);
                }
            }
        }
        
        // WebSocket connection for real-time PSS events
        let websocket = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const reconnectDelay = 2000;
        
        function setupWebSocketConnection() {
            console.log('üîó Setting up WebSocket connection...');
            
            try {
                // Get WebSocket URL from current location or use default
                const currentHost = window.location.hostname;
                const wsHost = currentHost === 'localhost' || currentHost === '127.0.0.1' ? '127.0.0.1' : currentHost;
                const wsUrl = `ws://${wsHost}:3001`;
                
                console.log(`üîó Connecting to WebSocket server at: ${wsUrl}`);
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = function(event) {
                    console.log('‚úÖ WebSocket connected to reStrike VTA server');
                    updateConnectionStatus(true);
                    reconnectAttempts = 0;
                    
                    // Send ping to keep connection alive
                    setInterval(() => {
                        if (websocket.readyState === WebSocket.OPEN) {
                            websocket.send('ping');
                        }
                    }, 30000);
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('üì° WebSocket message received:', data);
                        
                        if (data.type === 'pss_event') {
                            console.log('üéØ PSS event received via WebSocket:', data.data.type);
                            handlePssEvent(data.data);
                        } else if (data.type === 'connection') {
                            console.log('üîó Connection confirmed:', data.message);
                        }
                    } catch (error) {
                        console.error('‚ùå Error parsing WebSocket message:', error);
                    }
                };
                
                websocket.onclose = function(event) {
                    console.log('üîå WebSocket connection closed');
                    updateConnectionStatus(false);
                    
                    // Attempt to reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        console.log(`üîÑ Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                        setTimeout(setupWebSocketConnection, reconnectDelay);
                    } else {
                        console.error('‚ùå Max reconnection attempts reached, falling back to localStorage');
                        setupFallbackEventSystem();
                    }
                };
                
                websocket.onerror = function(error) {
                    console.error('‚ùå WebSocket error:', error);
                    updateConnectionStatus(false);
                };
                
            } catch (error) {
                console.error('‚ùå Failed to setup WebSocket connection:', error);
                setupFallbackEventSystem();
            }
        }
        
        // Fallback event system for testing
        function setupFallbackEventSystem() {
            console.log('üîÑ Setting up fallback event system...');
            
            // Listen for custom events (for testing)
            window.addEventListener('pss-event', (event) => {
                console.log('üì° Fallback PSS event received:', event.detail);
                handlePssEvent(event.detail);
            });
            
            // Listen for broadcasted events via localStorage
            window.addEventListener('storage', (e) => {
                if (e.key === 'pss_event' && e.newValue) {
                    try {
                        const eventData = JSON.parse(e.newValue);
                        if (eventData.type === 'pss_event') {
                            console.log('üì° Received broadcasted PSS event:', eventData.data);
                            handlePssEvent(eventData.data);
                        }
                    } catch (error) {
                        console.error('‚ùå Error parsing broadcasted event:', error);
                    }
                }
            });
            
            // Simulate connection for testing
            setTimeout(() => {
                updateConnectionStatus(true);
                console.log('‚úÖ Fallback event system ready');
            }, 2000);
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Scoreboard overlay page loaded');
            
            // Check if scripts are loaded
            console.log('üîç Checking script availability...');
            console.log('üîç ScoreboardOverlay available:', typeof ScoreboardOverlay !== 'undefined');
            console.log('üîç ScoreboardNameManager available:', typeof ScoreboardNameManager !== 'undefined');
            
            // Initialize scoreboard when SVG loads
            const svgObject = document.getElementById('scoreboard-svg');
            svgObject.addEventListener('load', initializeScoreboard);
            
            // Setup WebSocket connection for real-time PSS events
            setupWebSocketConnection();
            
            // Initialize immediately if SVG is already loaded
            if (svgObject.contentDocument) {
                initializeScoreboard();
            }
        });
        
        // Export functions for external access
        window.ScoreboardOverlayManager = {
            handlePssEvent,
            updateConnectionStatus,
            scoreboardInstance: () => scoreboardInstance,
            nameManager: () => nameManager
        };
        
        console.log('üéØ Scoreboard overlay script loaded');
    </script>
</body>
</html> 