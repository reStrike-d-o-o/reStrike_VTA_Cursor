<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>reStrike VTA - Scoreboard Overlay</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: transparent;
            font-family: Arial, sans-serif;
        }
        
        #scoreboard-container {
            width: 1920px;
            height: 1080px;
            position: relative;
        }
        
        #scoreboard-svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Animation classes for score updates */
        .score-update {
            animation: scorePulse 0.5s ease-in-out;
        }
        
        @keyframes scorePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Connection status indicator */
        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            border: 2px solid #ffffff;
            z-index: 1000;
        }
        
        .connection-status.connected {
            background: #10b981;
        }
        
        /* Debug panel (hidden by default) */
        .debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
        
        .debug-panel.show {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Connection Status Indicator -->
    <div id="connection-status" class="connection-status"></div>
    
    <!-- Debug Panel -->
    <div id="debug-panel" class="debug-panel">
        <div>PSS Status: <span id="pss-status">Disconnected</span></div>
        <div>Last Update: <span id="last-update">Never</span></div>
        <div>Blue Player: <span id="debug-blue">-</span></div>
        <div>Red Player: <span id="debug-red">-</span></div>
        <div>Blue Score: <span id="debug-blue-score">0</span></div>
        <div>Red Score: <span id="debug-red-score">0</span></div>
    </div>
    
    <!-- Scoreboard Container -->
    <div id="scoreboard-container">
        <object id="scoreboard-svg" data="assets/scoreboard/scoreboard-overlay.svg" type="image/svg+xml">
            <!-- Fallback content if SVG fails to load -->
            <div style="width: 1920px; height: 1080px; background: #000; color: white; display: flex; align-items: center; justify-content: center; font-size: 48px;">
                Scoreboard Overlay Loading...
            </div>
        </object>
    </div>

    <!-- JavaScript Utilities -->
    <script src="assets/scoreboard/scoreboard-name-utils.js"></script>
    <script src="assets/scoreboard/scoreboard-utils.js"></script>
    
    <!-- PSS Event Integration Script -->
    <script>
        // Global variables
        let scoreboardInstance = null;
        let nameManager = null;
        
        // Global variables for connection status
        let isConnected = false;
        let lastUpdateTime = null;
        
        // Debug mode (set to true to show debug panel)
        const DEBUG_MODE = false;
        
        // Initialize the scoreboard when SVG loads
        function initializeScoreboard() {
            const svgObject = document.getElementById('scoreboard-svg');
            
            if (!svgObject) {
                console.error('‚ùå SVG object not found');
                return;
            }
            
            console.log('üîç Checking SVG object:', svgObject);
            console.log('üîç SVG object readyState:', svgObject.readyState);
            
            const svgDoc = svgObject.contentDocument || svgObject.contentWindow?.document;
            
            console.log('üîç SVG document:', svgDoc);
            
            if (svgDoc && svgDoc.querySelector('svg')) {
                console.log('üéØ Scoreboard SVG loaded, initializing...');
                
                // Check if ScoreboardOverlay class is available
                if (typeof ScoreboardOverlay === 'undefined') {
                    console.error('‚ùå ScoreboardOverlay class not found');
                    console.log('üîç Available window objects:', Object.keys(window).filter(key => key.includes('Scoreboard')));
                    setTimeout(initializeScoreboard, 1000); // Retry after 1 second
                    return;
                }
                
                // Check if ScoreboardNameManager class is available
                if (typeof ScoreboardNameManager === 'undefined') {
                    console.error('‚ùå ScoreboardNameManager class not found');
                    console.log('üîç Available window objects:', Object.keys(window).filter(key => key.includes('Name')));
                    setTimeout(initializeScoreboard, 1000); // Retry after 1 second
                    return;
                }
                
                try {
                    // Initialize scoreboard utilities
                    scoreboardInstance = new ScoreboardOverlay(svgDoc.querySelector('svg'));
                    nameManager = new ScoreboardNameManager();
                    
                    // Set initial state
                    updateConnectionStatus(false);
                    updateDebugInfo();
                    
                    // Show debug panel if in debug mode
                    if (DEBUG_MODE) {
                        document.getElementById('debug-panel').classList.add('show');
                    }
                    
                    console.log('‚úÖ Scoreboard initialized successfully');
                } catch (error) {
                    console.error('‚ùå Error initializing scoreboard:', error);
                    setTimeout(initializeScoreboard, 1000); // Retry after 1 second
                }
            } else {
                console.error('‚ùå Failed to load SVG document');
                console.log('üîç SVG object contentDocument:', svgObject.contentDocument);
                console.log('üîç SVG object contentWindow:', svgObject.contentWindow);
                setTimeout(initializeScoreboard, 1000); // Retry after 1 second
            }
        }
        
        // Update connection status indicator
        function updateConnectionStatus(connected) {
            isConnected = connected;
            const statusElement = document.getElementById('connection-status');
            const pssStatusElement = document.getElementById('pss-status');
            
            if (connected) {
                statusElement.classList.add('connected');
                pssStatusElement.textContent = 'Connected';
                pssStatusElement.style.color = '#10b981';
            } else {
                statusElement.classList.remove('connected');
                pssStatusElement.textContent = 'Disconnected';
                pssStatusElement.style.color = '#ef4444';
            }
        }
        
        // Update debug information
        function updateDebugInfo() {
            const lastUpdateElement = document.getElementById('last-update');
            if (lastUpdateTime) {
                lastUpdateElement.textContent = lastUpdateTime.toLocaleTimeString();
            }
        }
        
        // Handle PSS events from Tauri
        function handlePssEvent(event) {
            console.log('üì° Received PSS event:', event);
            console.log('üì° Event type:', event.type);
            console.log('üì° Full event structure:', JSON.stringify(event, null, 2));
            lastUpdateTime = new Date();
            
            if (!scoreboardInstance) {
                console.warn('‚ö†Ô∏è Scoreboard not initialized, ignoring event');
                return;
            }
            
            try {
                // Update connection status
                updateConnectionStatus(true);
                
                // Handle different event types
                switch (event.type) {
                    case 'athletes':
                        handleAthletesEvent(event);
                        break;
                    case 'match_config':
                        handleMatchConfigEvent(event);
                        break;
                    case 'current_scores':
                        handleScoresEvent(event);
                        break;
                    case 'fight_loaded':
                        handleFightLoadedEvent(event);
                        break;
                    case 'warnings':
                        handleWarningsEvent(event);
                        break;
                    case 'winner_rounds':
                        handleWinnerRoundsEvent(event);
                        break;
                    case 'winner':
                        handleMatchEndEvent(event);
                        break;
                    case 'clock':
                        handleClockEvent(event);
                        break;
                    case 'round':
                        handleRoundEvent(event);
                        break;
                    case 'supervision':
                        handleSupervisionEvent(event);
                        break;
                    case 'fight_ready':
                        handleFightReadyEvent(event);
                        break;
                    case 'injury':
                        handleInjuryEvent(event);
                        break;
                    case 'raw':
                        handleRawEvent(event);
                        break;
                    default:
                        // Check if this is an injury event disguised as 'other' type
                        if (event.type === 'other' && (event.description?.includes('Injury') || event.event?.includes('Injury'))) {
                            console.log('ü©π Parsing injury event from other type:', event);
                            handleInjuryEventFromOther(event);
                        } else {
                            console.log('üìù Unhandled event type:', event.type);
                        }
                }
                
                updateDebugInfo();
                
            } catch (error) {
                console.error('‚ùå Error handling PSS event:', error);
            }
        }
        
        // Handle athletes event
        function handleAthletesEvent(event) {
            console.log('üë• Updating athletes:', event);
            
            // Try to parse raw_data first, then fall back to direct access
            let athleteData = null;
            
            if (event.raw_data) {
                try {
                    athleteData = JSON.parse(event.raw_data);
                    console.log('üë• Parsed raw_data:', athleteData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try direct access
            const data = athleteData || event;
            console.log('üë• Using data source:', athleteData ? 'raw_data' : 'direct');
            console.log('üë• athlete1:', data.athlete1);
            console.log('üë• athlete2:', data.athlete2);
            
            // Update player names - athlete1 maps to player1 (blue), athlete2 maps to player2 (red)
            if (data.athlete1 && data.athlete1.long) {
                console.log('‚úÖ Updating blue player name to:', data.athlete1.long);
                scoreboardInstance.updatePlayerName('blue', data.athlete1.long);
                document.getElementById('debug-blue').textContent = data.athlete1.long;
            } else {
                console.warn('‚ö†Ô∏è No athlete1.long found in event');
            }
            
            if (data.athlete2 && data.athlete2.long) {
                console.log('‚úÖ Updating red player name to:', data.athlete2.long);
                scoreboardInstance.updatePlayerName('red', data.athlete2.long);
                document.getElementById('debug-red').textContent = data.athlete2.long;
            } else {
                console.warn('‚ö†Ô∏è No athlete2.long found in event');
            }
            
            // Update countries - athlete1.country and athlete2.country are already IOC codes
            if (data.athlete1 && data.athlete1.country) {
                console.log('‚úÖ Updating blue player country to:', data.athlete1.country);
                scoreboardInstance.updateCountry('blue', data.athlete1.country);
            } else {
                console.warn('‚ö†Ô∏è No athlete1.country found in event');
            }
            
            if (data.athlete2 && data.athlete2.country) {
                console.log('‚úÖ Updating red player country to:', data.athlete2.country);
                scoreboardInstance.updateCountry('red', data.athlete2.country);
            } else {
                console.warn('‚ö†Ô∏è No athlete2.country found in event');
            }
        }
        
        // Handle match config event
        function handleMatchConfigEvent(event) {
            console.log('üèÜ Updating match config:', event);
            
            // Try to parse raw_data first, then fall back to direct access
            let configData = null;
            
            if (event.raw_data) {
                try {
                    configData = JSON.parse(event.raw_data);
                    console.log('üèÜ Parsed raw_data:', configData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try direct access
            const data = configData || event;
            console.log('üèÜ Using data source:', configData ? 'raw_data' : 'direct');
            console.log('üèÜ weight:', data.weight);
            console.log('üèÜ division:', data.division);
            console.log('üèÜ category:', data.category);
            console.log('üèÜ number:', data.number);
            
            // Use the new combined method to update all match info at once
            if (data.weight || data.division || data.category) {
                console.log('‚úÖ Updating match info with:', data.weight, data.division, data.category);
                scoreboardInstance.updateMatchInfo(data.weight, data.division, data.category);
            } else {
                console.warn('‚ö†Ô∏è No weight, division, or category found in match config event');
            }
            
            if (data.number) {
                console.log('‚úÖ Updating match number to:', data.number);
                // Update match number in SVG
                const matchNumberElement = scoreboardInstance.svg.getElementById('matchNumber');
                if (matchNumberElement) {
                    matchNumberElement.textContent = `#${data.number}`;
                    console.log('‚úÖ Match number element updated');
                } else {
                    console.warn('‚ö†Ô∏è Could not find matchNumber element in SVG');
                }
            } else {
                console.warn('‚ö†Ô∏è No match number found in match config event');
            }
        }
        
        // Handle scores event
        function handleScoresEvent(event) {
            console.log('üìä Updating scores:', event);
            
            // Try to parse raw_data first, then fall back to direct access
            let scoreData = null;
            
            if (event.raw_data) {
                try {
                    scoreData = JSON.parse(event.raw_data);
                    console.log('üìä Parsed raw_data:', scoreData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try direct access
            const data = scoreData || event;
            console.log('üìä Using data source:', scoreData ? 'raw_data' : 'direct');
            
            // Check for both possible structures (nested and flat)
            let blueScore = 0;
            let redScore = 0;
            
            if (data.athlete1_score !== undefined && data.athlete2_score !== undefined) {
                // Flat structure (old format)
                blueScore = data.athlete1_score;
                redScore = data.athlete2_score;
                console.log('üìä Using flat structure for scores');
            } else if (data.athlete1 && data.athlete1.score !== undefined && data.athlete2 && data.athlete2.score !== undefined) {
                // Nested structure (new format)
                blueScore = data.athlete1.score;
                redScore = data.athlete2.score;
                console.log('üìä Using nested structure for scores');
            } else {
                console.warn('‚ö†Ô∏è No valid score structure found in event');
            }
            
            console.log('üìä Blue score:', blueScore, 'Red score:', redScore);
            
            scoreboardInstance.updateScore('blue', blueScore);
            scoreboardInstance.updateScore('red', redScore);
            
            // Update debug info
            document.getElementById('debug-blue-score').textContent = blueScore;
            document.getElementById('debug-red-score').textContent = redScore;
        }
        
        // Handle fight loaded event
        function handleFightLoadedEvent(event) {
            console.log('ü•ä Fight loaded event:', event);
            updateConnectionStatus(true);
            
            // Apply typewriter effect for new match
            if (scoreboardInstance) {
                setTimeout(() => {
                    scoreboardInstance.applyNewMatchEffect();
                }, 500); // Small delay to ensure all data is loaded
            }
        }
        
        // Handle warnings event
        function handleWarningsEvent(event) {
            console.log('‚ö†Ô∏è Warnings event:', event);
            
            // Try to parse raw_data first, then fall back to direct access
            let warningData = null;
            
            if (event.raw_data) {
                try {
                    warningData = JSON.parse(event.raw_data);
                    console.log('‚ö†Ô∏è Parsed raw_data:', warningData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try direct access
            const data = warningData || event;
            console.log('‚ö†Ô∏è Using data source:', warningData ? 'raw_data' : 'direct');
            
            // Check for both possible structures (nested and flat)
            let blueWarnings = 0;
            let redWarnings = 0;
            
            if (data.athlete1_warnings !== undefined && data.athlete2_warnings !== undefined) {
                // Flat structure (old format)
                blueWarnings = data.athlete1_warnings;
                redWarnings = data.athlete2_warnings;
                console.log('‚ö†Ô∏è Using flat structure for warnings');
            } else if (data.athlete1 && data.athlete1.warnings !== undefined && data.athlete2 && data.athlete2.warnings !== undefined) {
                // Nested structure (new format)
                blueWarnings = data.athlete1.warnings;
                redWarnings = data.athlete2.warnings;
                console.log('‚ö†Ô∏è Using nested structure for warnings');
            } else {
                console.warn('‚ö†Ô∏è No valid warnings structure found in event');
            }
            
            console.log('‚ö†Ô∏è Blue warnings:', blueWarnings, 'Red warnings:', redWarnings);
            
            // athlete1 maps to blue (player1), athlete2 maps to red (player2)
            if (blueWarnings !== undefined) {
                scoreboardInstance.updatePenalties('blue', null, blueWarnings);
            }
            
            if (redWarnings !== undefined) {
                scoreboardInstance.updatePenalties('red', null, redWarnings);
            }
        }
        
        // Handle winner rounds event
        function handleWinnerRoundsEvent(event) {
            console.log('üèÜ Winner rounds event:', event);
            
            // Reset current scores to 0:0 for new round
            scoreboardInstance.updateScore('blue', 0);
            scoreboardInstance.updateScore('red', 0);
            
            // Reset warnings to 0:0 for new round
            scoreboardInstance.updatePenalties('blue', null, 0);
            scoreboardInstance.updatePenalties('red', null, 0);
            
            // Update rounds won - athlete1 (player1/blue) = winner 1, athlete2 (player2/red) = winner 2
            if (event.round1_winner !== undefined) {
                const blueWins = (event.round1_winner === 1 ? 1 : 0) + 
                                (event.round2_winner === 1 ? 1 : 0) + 
                                (event.round3_winner === 1 ? 1 : 0);
                const redWins = (event.round1_winner === 2 ? 1 : 0) + 
                               (event.round2_winner === 2 ? 1 : 0) + 
                               (event.round3_winner === 2 ? 1 : 0);
                
                console.log(`üèÜ Updating round wins - Blue: ${blueWins}, Red: ${redWins}`);
                scoreboardInstance.updateRoundWins('blue', blueWins);
                scoreboardInstance.updateRoundWins('red', redWins);
            }
        }
        
        // Handle match end event (when winner is announced)
        function handleMatchEndEvent(event) {
            console.log('üèÅ Match end event:', event);
            
            // Update final scores and winner information
            if (event.winner) {
                console.log(`üèÜ Match winner: ${event.winner}`);
                // You can add winner announcement logic here
            }
        }
        
        // Handle clock event
        function handleClockEvent(event) {
            console.log('‚è∞ Clock event:', event);
            
            if (event.time) {
                // Parse time in format "m:ss" or "ss"
                let minutes = 0;
                let seconds = 0;
                
                if (event.time.includes(':')) {
                    const parts = event.time.split(':');
                    minutes = parseInt(parts[0]) || 0;
                    seconds = parseInt(parts[1]) || 0;
                } else {
                    seconds = parseInt(event.time) || 0;
                }
                
                scoreboardInstance.updateTimer(minutes, seconds);
            }
        }
        
        // Handle round event
        function handleRoundEvent(event) {
            console.log('üîÑ Round event:', event);
            
            if (event.current_round) {
                scoreboardInstance.updateRound(event.current_round);
                console.log(`üîÑ Updated to round: ${event.current_round}`);
                
                // Reset clock to 2:00 when a new round starts
                scoreboardInstance.updateTimer(2, 0);
                console.log('‚è∞ Reset clock to 2:00 for new round');
            }
        }
        
        // Handle supervision event (warnings reset)
        function handleSupervisionEvent(event) {
            console.log('üëÅÔ∏è Supervision event:', event);
            
            // Try to parse raw_data first, then fall back to direct access
            let supervisionData = null;
            
            if (event.raw_data) {
                try {
                    supervisionData = JSON.parse(event.raw_data);
                    console.log('üëÅÔ∏è Parsed raw_data:', supervisionData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try direct access
            const data = supervisionData || event;
            console.log('üëÅÔ∏è Using data source:', supervisionData ? 'raw_data' : 'direct');
            
            // Check for supervision value (0 = reset warnings)
            let supervisionValue = 0;
            
            if (data.supervision !== undefined) {
                supervisionValue = data.supervision;
            } else if (data.value !== undefined) {
                supervisionValue = data.value;
            }
            
            console.log('üëÅÔ∏è Supervision value:', supervisionValue);
            
            // If supervision is 0, reset warnings
            if (supervisionValue === 0) {
                console.log('üîÑ Resetting warnings due to supervision event');
                scoreboardInstance.updatePenalties('blue', null, 0);
                scoreboardInstance.updatePenalties('red', null, 0);
            }
        }
        
        // Handle fight ready event
        function handleFightReadyEvent(event) {
            console.log('ü•ä Fight ready event:', event);
            updateConnectionStatus(true);
        }
        
        // Handle injury event (for properly typed events)
        function handleInjuryEvent(event) {
            console.log('ü©π Injury event:', event);
            
            if (event.time !== undefined) {
                scoreboardInstance.updateInjuryTime(event.time);
            }
            
            if (event.action) {
                if (event.action === 'show') {
                    scoreboardInstance.showInjurySection();
                } else if (event.action === 'hide') {
                    scoreboardInstance.hideInjurySection();
                } else if (event.action === 'reset') {
                    scoreboardInstance.resetInjuryTime();
                }
            }
        }
        
        // Handle injury event from 'other' type (parsing from description/event string)
        function handleInjuryEventFromOther(event) {
            console.log('ü©π Parsing injury event from other type:', event);
            
            // Extract injury data from description or event string
            const injuryString = event.description || event.event || '';
            
            // Parse the injury data using regex
            const injuryMatch = injuryString.match(/Injury\s*\{\s*athlete:\s*(\d+),\s*time:\s*"([^"]+)",\s*action:\s*(Some\("([^"]+)"\)|None)\s*\}/);
            
            if (injuryMatch) {
                const athlete = parseInt(injuryMatch[1]);
                const time = injuryMatch[2];
                const actionRaw = injuryMatch[3];
                const action = injuryMatch[4] || null; // Extract from Some("action") or null
                
                console.log('ü©π Parsed injury data:', { athlete, time, action });
                
                // Update injury time
                if (time) {
                    scoreboardInstance.updateInjuryTime(time);
                }
                
                // Handle action
                if (action === 'show') {
                    scoreboardInstance.showInjurySection();
                    console.log('‚úÖ Showing injury section');
                } else if (action === 'hide') {
                    scoreboardInstance.hideInjurySection();
                    console.log('‚úÖ Hiding injury section');
                } else if (action === 'reset') {
                    scoreboardInstance.resetInjuryTime();
                    console.log('‚úÖ Resetting injury time');
                } else if (action === null) {
                    // Just update the time without changing visibility
                    console.log('‚úÖ Updated injury time only');
                }
            } else {
                console.warn('‚ö†Ô∏è Could not parse injury data from string:', injuryString);
            }
        }
        
        // Handle raw PSS events (for backward compatibility)
        function handleRawEvent(event) {
            console.log('üìù Raw PSS event:', event);
            
            if (!event.message) return;
            
            // Parse raw match config (mch;) lines
            if (event.message.startsWith('mch;')) {
                try {
                    const parts = event.message.split(';');
                    const matchConfig = {
                        number: parseInt(parts[1]) || 0,
                        category: parts[2] || '',
                        weight: parts[3]?.replace(/\s+/g, '') || '',
                        division: parts[10] || '',
                    };
                    
                    handleMatchConfigEvent(matchConfig);
                } catch (error) {
                    console.error('‚ùå Error parsing raw mch line:', error);
                }
            }
            
            // Parse warnings (wg1;wg2;) lines
            else if (event.message.includes('wg1;') && event.message.includes('wg2;')) {
                try {
                    const parts = event.message.split(';');
                    const warnings = {
                        athlete1_warnings: parseInt(parts[1]) || 0,
                        athlete2_warnings: parseInt(parts[3]) || 0,
                        type: 'warnings'
                    };
                    
                    handleWarningsEvent(warnings);
                } catch (error) {
                    console.error('‚ùå Error parsing raw warnings line:', error);
                }
            }
            
            // Parse winner rounds (wrd;) lines
            else if (event.message.startsWith('wrd;')) {
                try {
                    const parts = event.message.split(';');
                    const winnerRounds = {
                        round1_winner: parseInt(parts[2]) || 0,
                        round2_winner: parseInt(parts[4]) || 0,
                        round3_winner: parseInt(parts[6]) || 0,
                        type: 'winner_rounds'
                    };
                    
                    handleWinnerRoundsEvent(winnerRounds);
                } catch (error) {
                    console.error('‚ùå Error parsing raw winner rounds line:', error);
                }
            }
            
            // Parse clock (clk;) lines
            else if (event.message.startsWith('clk;')) {
                try {
                    const parts = event.message.split(';');
                    const clock = {
                        time: parts[1] || '0:00',
                        action: parts[2] || null,
                        type: 'clock'
                    };
                    
                    handleClockEvent(clock);
                } catch (error) {
                    console.error('‚ùå Error parsing raw clock line:', error);
                }
            }
            
            // Parse round (rnd;) lines
            else if (event.message.startsWith('rnd;')) {
                try {
                    const parts = event.message.split(';');
                    const round = {
                        current_round: parseInt(parts[1]) || 1,
                        type: 'round'
                    };
                    
                    handleRoundEvent(round);
                } catch (error) {
                    console.error('‚ùå Error parsing raw round line:', error);
                }
            }
            
            // Parse fight ready (rdy;) lines
            else if (event.message.startsWith('rdy;')) {
                try {
                    const parts = event.message.split(';');
                    const fightReady = {
                        status: parts[1] || 'FightReady',
                        type: 'fight_ready'
                    };
                    
                    handleFightReadyEvent(fightReady);
                } catch (error) {
                    console.error('‚ùå Error parsing raw fight ready line:', error);
                }
            }
            
            // Parse scores (sc1;sc2;) lines
            else if (event.message.includes('sc1;') && event.message.includes('sc2;')) {
                try {
                    const parts = event.message.split(';');
                    const scores = {
                        athlete1_score: parseInt(parts[1]) || 0,
                        athlete2_score: parseInt(parts[3]) || 0,
                        type: 'current_scores'
                    };
                    
                    console.log(`üìä Parsed score message: ${event.message}`);
                    console.log(`üìä Parts:`, parts);
                    console.log(`üìä Scores: blue=${scores.athlete1_score}, red=${scores.athlete2_score}`);
                    console.log(`üìä Scoreboard instance:`, scoreboardInstance);
                    
                    handleScoresEvent(scores);
                } catch (error) {
                    console.error('‚ùå Error parsing raw scores line:', error);
                }
            }
            
            // Parse structured current_scores events from WebSocket
            else if (event.type === 'current_scores') {
                try {
                    const scores = {
                        athlete1_score: event.athlete1_score || event.structured_data?.athlete1_score || 0,
                        athlete2_score: event.athlete2_score || event.structured_data?.athlete2_score || 0,
                        type: 'current_scores'
                    };
                    
                    console.log(`üìä Parsed structured current_scores: blue=${scores.athlete1_score}, red=${scores.athlete2_score}`);
                    handleScoresEvent(scores);
                } catch (error) {
                    console.error('‚ùå Error parsing structured current_scores:', error);
                }
            }
            
            // Parse supervision (sv;) lines
            else if (event.message.startsWith('sv;')) {
                try {
                    const parts = event.message.split(';');
                    const supervision = {
                        value: parseInt(parts[1]) || 0,
                        type: 'supervision'
                    };
                    
                    handleSupervisionEvent(supervision);
                } catch (error) {
                    console.error('‚ùå Error parsing raw supervision line:', error);
                }
            }
            
            // Parse injury time (ij1;, ij2;, ij0;) lines
            else if (event.message.startsWith('ij1;') || event.message.startsWith('ij2;') || event.message.startsWith('ij0;')) {
                try {
                    const parts = event.message.split(';');
                    const athlete = event.message.startsWith('ij1;') ? 1 : 
                                  event.message.startsWith('ij2;') ? 2 : 0;
                    const time = parts[1] || '0:00';
                    const action = parts[2] || null;
                    
                    const injury = {
                        athlete: athlete,
                        time: time,
                        action: action,
                        type: 'injury'
                    };
                    
                    handleInjuryEvent(injury);
                } catch (error) {
                    console.error('‚ùå Error parsing raw injury line:', error);
                }
            }
        }
        
        // WebSocket connection for real-time PSS events
        let websocket = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const reconnectDelay = 2000;
        
        function setupWebSocketConnection() {
            console.log('üîó Setting up WebSocket connection...');
            
            try {
                // Get WebSocket URL from current location or use default
                const currentHost = window.location.hostname;
                const wsHost = currentHost === 'localhost' || currentHost === '127.0.0.1' ? '127.0.0.1' : currentHost;
                const wsUrl = `ws://${wsHost}:3001`;
                
                console.log(`üîó Connecting to WebSocket server at: ${wsUrl}`);
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = function(event) {
                    console.log('‚úÖ WebSocket connected to reStrike VTA server');
                    updateConnectionStatus(true);
                    reconnectAttempts = 0;
                    
                    // Send ping to keep connection alive
                    setInterval(() => {
                        if (websocket.readyState === WebSocket.OPEN) {
                            websocket.send('ping');
                        }
                    }, 30000);
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('üì° WebSocket message received:', data);
                        console.log('üì° Raw WebSocket data:', event.data);
                        
                        if (data.type === 'pss_event') {
                            console.log('üéØ PSS event received via WebSocket:', data.data.type);
                            console.log('üéØ PSS event data:', data.data);
                            handlePssEvent(data.data);
                        } else if (data.type === 'connection') {
                            console.log('üîó Connection confirmed:', data.message);
                        } else {
                            console.log('üì° Other WebSocket message type:', data.type);
                        }
                    } catch (error) {
                        console.error('‚ùå Error parsing WebSocket message:', error);
                        console.error('‚ùå Raw message was:', event.data);
                    }
                };
                
                websocket.onclose = function(event) {
                    console.log('üîå WebSocket connection closed');
                    updateConnectionStatus(false);
                    
                    // Attempt to reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        console.log(`üîÑ Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                        setTimeout(setupWebSocketConnection, reconnectDelay);
                    } else {
                        console.error('‚ùå Max reconnection attempts reached, falling back to localStorage');
                        setupFallbackEventSystem();
                    }
                };
                
                websocket.onerror = function(error) {
                    console.error('‚ùå WebSocket error:', error);
                    updateConnectionStatus(false);
                };
                
            } catch (error) {
                console.error('‚ùå Failed to setup WebSocket connection:', error);
                setupFallbackEventSystem();
            }
        }
        
        // Fallback event system for testing
        function setupFallbackEventSystem() {
            console.log('üîÑ Setting up fallback event system...');
            
            // Listen for custom events (for testing)
            window.addEventListener('pss-event', (event) => {
                console.log('üì° Fallback PSS event received:', event.detail);
                handlePssEvent(event.detail);
            });
            
            // Listen for broadcasted events via localStorage
            window.addEventListener('storage', (e) => {
                if (e.key === 'pss_event' && e.newValue) {
                    try {
                        const eventData = JSON.parse(e.newValue);
                        if (eventData.type === 'pss_event') {
                            console.log('üì° Received broadcasted PSS event:', eventData.data);
                            handlePssEvent(eventData.data);
                        }
                    } catch (error) {
                        console.error('‚ùå Error parsing broadcasted event:', error);
                    }
                }
            });
            
            // Simulate connection for testing
            setTimeout(() => {
                updateConnectionStatus(true);
                console.log('‚úÖ Fallback event system ready');
            }, 2000);
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Scoreboard overlay page loaded');
            
            // Check if scripts are loaded
            console.log('üîç Checking script availability...');
            console.log('üîç ScoreboardOverlay available:', typeof ScoreboardOverlay !== 'undefined');
            console.log('üîç ScoreboardNameManager available:', typeof ScoreboardNameManager !== 'undefined');
            
            // Initialize scoreboard when SVG loads
            const svgObject = document.getElementById('scoreboard-svg');
            svgObject.addEventListener('load', initializeScoreboard);
            
            // Setup WebSocket connection for real-time PSS events
            setupWebSocketConnection();
            
            // Initialize immediately if SVG is already loaded
            if (svgObject.contentDocument) {
                initializeScoreboard();
            }
        });
        
        // Cleanup when page is unloaded
        window.addEventListener('beforeunload', () => {
            console.log('üßπ Cleaning up dramatic countdown...');
            // No dramatic countdown to clean up
        });
        
        // Export functions for external access
        window.ScoreboardOverlayManager = {
            handlePssEvent,
            updateConnectionStatus,
            scoreboardInstance: () => scoreboardInstance,
            nameManager: () => nameManager
        };
        
        console.log('üéØ Scoreboard overlay script loaded');
    </script>
</body>
</html> 