<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>reStrike VTA - Scoreboard Overlay</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: transparent;
            font-family: Arial, sans-serif;
        }
        
        #scoreboard-container {
            width: 1920px;
            height: 1080px;
            position: relative;
        }
        
        #scoreboard-svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Animation classes for score updates */
        .score-update {
            animation: scorePulse 0.5s ease-in-out;
        }
        
        @keyframes scorePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Connection status indicator */
        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            border: 2px solid #ffffff;
            z-index: 1000;
        }
        
        .connection-status.connected {
            background: #10b981;
        }
        
        /* Debug panel (hidden by default) */
        .debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
        
        .debug-panel.show {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Connection Status Indicator -->
    <div id="connection-status" class="connection-status"></div>
    
    <!-- Debug Panel -->
    <div id="debug-panel" class="debug-panel">
        <div>PSS Status: <span id="pss-status">Disconnected</span></div>
        <div>Last Update: <span id="last-update">Never</span></div>
        <div>Blue Player: <span id="debug-blue">-</span></div>
        <div>Red Player: <span id="debug-red">-</span></div>
        <div>Blue Score: <span id="debug-blue-score">0</span></div>
        <div>Red Score: <span id="debug-red-score">0</span></div>
    </div>
    
    <!-- Scoreboard Container -->
    <div id="scoreboard-container">
        <object id="scoreboard-svg" data="assets/scoreboard/scoreboard-overlay.svg" type="image/svg+xml">
            <!-- Fallback content if SVG fails to load -->
            <div style="width: 1920px; height: 1080px; background: #000; color: white; display: flex; align-items: center; justify-content: center; font-size: 48px;">
                Scoreboard Overlay Loading...
            </div>
        </object>
    </div>

    <!-- JavaScript Utilities -->
    <script src="assets/scoreboard/scoreboard-name-utils.js"></script>
    <script src="assets/scoreboard/scoreboard-utils.js"></script>
    
    <!-- PSS Event Integration Script -->
    <script>
        // Global variables
        let scoreboardInstance = null;
        let nameManager = null;
        
        // Global variables for connection status and match config
        let isConnected = false;
        let lastUpdateTime = null;
        let roundDuration = 120; // Default 2 minutes (120 seconds)
        
        // Debug mode (set to true to show debug panel)
        const DEBUG_MODE = false;
        
        // ===== ROBUST MANUAL OVERRIDE DETECTION SYSTEM =====
        
        // Manual override detection state
        const manualOverrideState = {
            // Clock state tracking
            clockState: 'stopped', // 'running', 'stopped'
            lastClockTime: null,
            lastClockAction: null,
            manualOverrideActive: false, // true when between clk;{};stop and clk;{};start
            
            // Recent events tracking (last 10 events for pattern detection)
            recentEvents: [],
            maxRecentEvents: 10,
            
            // Manual change detection
            lastManualRoundChange: null,
            lastManualScoreChange: null,
            lastManualTimeChange: null,
            
            // Score tracking for jump detection
            lastBlueScore: 0,
            lastRedScore: 0,
            
            // Warning tracking
            lastBlueWarnings: 0,
            lastRedWarnings: 0,
            
            // Time correction tracking
            hasRecentTimeCorrection: false,
            timeCorrectionThreshold: 5000, // 5 seconds
            lastTimeCorrection: null
        };
        
        // ===== SAFE UTILITY FUNCTIONS =====
        
        // Safely get current timestamp
        function getCurrentTimestamp() {
            try {
                return Date.now();
            } catch (error) {
                console.warn('‚ö†Ô∏è Error getting timestamp:', error);
                return 0;
            }
        }
        
        // Safely add event to recent events
        function addToRecentEvents(event) {
            try {
                if (!manualOverrideState.recentEvents) {
                    manualOverrideState.recentEvents = [];
                }
                
                manualOverrideState.recentEvents.push({
                    event: event,
                    timestamp: getCurrentTimestamp()
                });
                
                // Keep only the last N events
                if (manualOverrideState.recentEvents.length > manualOverrideState.maxRecentEvents) {
                    manualOverrideState.recentEvents.shift();
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Error adding to recent events:', error);
            }
        }
        
        // Safely check if clock is stopped
        function isClockStopped() {
            try {
                return manualOverrideState.clockState === 'stopped';
            } catch (error) {
                console.warn('‚ö†Ô∏è Error checking clock state:', error);
                return false;
            }
        }
        
        // Check if we're in manual override mode (between clk;{};stop and clk;{};start)
        function isInManualOverrideMode() {
            try {
                return manualOverrideState.clockState === 'stopped' && manualOverrideState.manualOverrideActive;
            } catch (error) {
                console.warn('‚ö†Ô∏è Error checking manual override mode:', error);
                return false;
            }
        }
        
        // Safely check if there was a recent time correction
        function hasRecentTimeCorrection() {
            try {
                if (!manualOverrideState.lastTimeCorrection) {
                    return false;
                }
                
                const timeSinceCorrection = getCurrentTimestamp() - manualOverrideState.lastTimeCorrection;
                return timeSinceCorrection < manualOverrideState.timeCorrectionThreshold;
            } catch (error) {
                console.warn('‚ö†Ô∏è Error checking time correction:', error);
                return false;
            }
        }
        
        // Safely calculate score jump
        function calculateScoreJump(newBlueScore, newRedScore) {
            try {
                const blueJump = Math.abs(newBlueScore - manualOverrideState.lastBlueScore);
                const redJump = Math.abs(newRedScore - manualOverrideState.lastRedScore);
                return Math.max(blueJump, redJump);
            } catch (error) {
                console.warn('‚ö†Ô∏è Error calculating score jump:', error);
                return 0;
            }
        }
        
        // Safely check for rapid point messages
        function hasRapidPointMessages() {
            try {
                if (!manualOverrideState.recentEvents || manualOverrideState.recentEvents.length < 2) {
                    return false;
                }
                
                const recentPointEvents = manualOverrideState.recentEvents.filter(item => {
                    return item.event && item.event.type === 'points';
                });
                
                if (recentPointEvents.length < 2) {
                    return false;
                }
                
                // Check if we have multiple point events within 2 seconds
                const timeWindow = 2000; // 2 seconds
                const now = getCurrentTimestamp();
                
                const recentPoints = recentPointEvents.filter(item => {
                    return (now - item.timestamp) < timeWindow;
                });
                
                return recentPoints.length >= 2;
            } catch (error) {
                console.warn('‚ö†Ô∏è Error checking rapid point messages:', error);
                return false;
            }
        }
        
        // ===== MANUAL OVERRIDE DETECTION FUNCTIONS =====
        
        // Detect manual round changes
        function isManualRoundChange(event) {
            try {
                if (!event || event.type !== 'round') {
                    return false;
                }
                
                // Manual override can only happen between clk;{};stop and clk;{};start events
                // Check if we're in manual override mode (clock stopped but not yet started)
                if (!isInManualOverrideMode()) {
                    return false;
                }
                
                // If we're in manual override mode, check for round changes
                console.log('üîç Manual round change detected: round change during manual override mode');
                return true;
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Error detecting manual round change:', error);
                return false;
            }
        }
        
        // Detect manual score changes
        function isManualScoreChange(event, newBlueScore, newRedScore) {
            try {
                if (!event) {
                    return false;
                }
                
                // Manual override can only happen between clk;{};stop and clk;{};start events
                // Check if we're in manual override mode (clock stopped but not yet started)
                if (!isInManualOverrideMode()) {
                    return false;
                }
                
                // If we're in manual override mode, check for score changes
                if (event.type === 'points' || event.type === 'current_scores') {
                    console.log('üîç Manual score change detected: score change during manual override mode');
                    return true;
                }
                
                return false;
            } catch (error) {
                console.warn('‚ö†Ô∏è Error detecting manual score change:', error);
                return false;
            }
        }
        
        // Detect manual time changes
        function isManualTimeChange(event) {
            try {
                if (!event || event.type !== 'clock') {
                    return false;
                }
                
                // Check for time correction action
                if (event.action === 'corr') {
                    console.log('üîç Manual time change detected: time correction action');
                    manualOverrideState.lastTimeCorrection = getCurrentTimestamp();
                    return true;
                }
                
                return false;
            } catch (error) {
                console.warn('‚ö†Ô∏è Error detecting manual time change:', error);
                return false;
            }
        }
        
        // Detect manual warning changes
        function isManualWarningChange(event, newBlueWarnings, newRedWarnings) {
            try {
                if (!event || event.type !== 'warnings') {
                    return false;
                }
                
                // Warning change during stopped clock
                if (isClockStopped()) {
                    console.log('üîç Manual warning change detected: warning change during stopped clock');
                    return true;
                }
                
                // Warning change during time correction
                if (hasRecentTimeCorrection()) {
                    console.log('üîç Manual warning change detected: warning change during time correction');
                    return true;
                }
                
                // Unusual warning pattern (multiple warnings in quick succession)
                const recentWarningEvents = manualOverrideState.recentEvents.filter(item => {
                    return item.event && item.event.type === 'warnings';
                });
                
                if (recentWarningEvents.length >= 2) {
                    const timeWindow = 3000; // 3 seconds
                    const now = getCurrentTimestamp();
                    
                    const recentWarnings = recentWarningEvents.filter(item => {
                        return (now - item.timestamp) < timeWindow;
                    });
                    
                    if (recentWarnings.length >= 2) {
                        console.log('üîç Manual warning change detected: rapid warning changes');
                        return true;
                    }
                }
                
                return false;
            } catch (error) {
                console.warn('‚ö†Ô∏è Error detecting manual warning change:', error);
                return false;
            }
        }
        
        // ===== MANUAL OVERRIDE HANDLING =====
        
        // Handle manual round change (preserve all data)
        function handleManualRoundChange(event) {
            try {
                console.log('üîÑ Handling manual round change:', event);
                
                // Update round number but preserve all other data
                if (scoreboardInstance && event.current_round) {
                    scoreboardInstance.updateRound(event.current_round);
                    console.log('‚úÖ Updated round to:', event.current_round, '(manual change)');
                }
                
                // DO NOT reset scores, warnings, or other data
                // This is the key difference from normal round changes
                
                manualOverrideState.lastManualRoundChange = getCurrentTimestamp();
                
            } catch (error) {
                console.error('‚ùå Error handling manual round change:', error);
            }
        }
        
        // Handle manual score change (accept immediately)
        function handleManualScoreChange(event, newBlueScore, newRedScore) {
            try {
                console.log('üîÑ Handling manual score change:', event);
                
                // Update scores immediately
                if (scoreboardInstance) {
                    scoreboardInstance.updateScore('blue', newBlueScore);
                    scoreboardInstance.updateScore('red', newRedScore);
                    console.log('‚úÖ Updated scores to:', newBlueScore, ':', newRedScore, '(manual change)');
                }
                
                // Update tracking state
                manualOverrideState.lastBlueScore = newBlueScore;
                manualOverrideState.lastRedScore = newRedScore;
                manualOverrideState.lastManualScoreChange = getCurrentTimestamp();
                
            } catch (error) {
                console.error('‚ùå Error handling manual score change:', error);
            }
        }
        
        // Handle manual time change (accept immediately)
        function handleManualTimeChange(event) {
            try {
                console.log('üîÑ Handling manual time change:', event);
                
                // Update time immediately
                if (scoreboardInstance && event.time) {
                    const timeParts = event.time.split(':');
                    if (timeParts.length === 2) {
                        const minutes = parseInt(timeParts[0]) || 0;
                        const seconds = parseInt(timeParts[1]) || 0;
                        scoreboardInstance.updateTimer(minutes, seconds);
                        console.log('‚úÖ Updated time to:', event.time, '(manual change)');
                    }
                }
                
                manualOverrideState.lastManualTimeChange = getCurrentTimestamp();
                
            } catch (error) {
                console.error('‚ùå Error handling manual time change:', error);
            }
        }
        
        // Handle manual warning change (accept immediately)
        function handleManualWarningChange(event, newBlueWarnings, newRedWarnings) {
            try {
                console.log('üîÑ Handling manual warning change:', event);
                
                // Update warnings immediately
                if (scoreboardInstance) {
                    scoreboardInstance.updatePenalties(newBlueWarnings, newRedWarnings);
                    console.log('‚úÖ Updated warnings to:', newBlueWarnings, ':', newRedWarnings, '(manual change)');
                }
                
                // Update tracking state
                manualOverrideState.lastBlueWarnings = newBlueWarnings;
                manualOverrideState.lastRedWarnings = newRedWarnings;
                
            } catch (error) {
                console.error('‚ùå Error handling manual warning change:', error);
            }
        }
        
        // Initialize the scoreboard when SVG loads
        function initializeScoreboard() {
            const svgObject = document.getElementById('scoreboard-svg');
            
            if (!svgObject) {
                console.error('‚ùå SVG object not found');
                return;
            }
            
            console.log('üîç Checking SVG object:', svgObject);
            console.log('üîç SVG object readyState:', svgObject.readyState);
            
            const svgDoc = svgObject.contentDocument || svgObject.contentWindow?.document;
            
            console.log('üîç SVG document:', svgDoc);
            
            if (svgDoc && svgDoc.querySelector('svg')) {
                console.log('üéØ Scoreboard SVG loaded, initializing...');
                
                // Check if ScoreboardOverlay class is available
                if (typeof ScoreboardOverlay === 'undefined') {
                    console.error('‚ùå ScoreboardOverlay class not found');
                    console.log('üîç Available window objects:', Object.keys(window).filter(key => key.includes('Scoreboard')));
                    setTimeout(initializeScoreboard, 1000); // Retry after 1 second
                    return;
                }
                
                // Check if ScoreboardNameManager class is available
                if (typeof ScoreboardNameManager === 'undefined') {
                    console.error('‚ùå ScoreboardNameManager class not found');
                    console.log('üîç Available window objects:', Object.keys(window).filter(key => key.includes('Name')));
                    setTimeout(initializeScoreboard, 1000); // Retry after 1 second
                    return;
                }
                
                try {
                    // Initialize scoreboard utilities
                    scoreboardInstance = new ScoreboardOverlay(svgDoc.querySelector('svg'));
                    nameManager = new ScoreboardNameManager();
                    
                    // Set initial state
                    updateConnectionStatus(false);
                    updateDebugInfo();
                    
                    // Show debug panel if in debug mode
                    if (DEBUG_MODE) {
                        document.getElementById('debug-panel').classList.add('show');
                    }
                    
                    console.log('‚úÖ Scoreboard initialized successfully');
                } catch (error) {
                    console.error('‚ùå Error initializing scoreboard:', error);
                    setTimeout(initializeScoreboard, 1000); // Retry after 1 second
                }
            } else {
                console.error('‚ùå Failed to load SVG document');
                console.log('üîç SVG object contentDocument:', svgObject.contentDocument);
                console.log('üîç SVG object contentWindow:', svgObject.contentWindow);
                setTimeout(initializeScoreboard, 1000); // Retry after 1 second
            }
        }
        
        // Update connection status indicator
        function updateConnectionStatus(connected) {
            isConnected = connected;
            const statusElement = document.getElementById('connection-status');
            const pssStatusElement = document.getElementById('pss-status');
            
            if (connected) {
                statusElement.classList.add('connected');
                pssStatusElement.textContent = 'Connected';
                pssStatusElement.style.color = '#10b981';
            } else {
                statusElement.classList.remove('connected');
                pssStatusElement.textContent = 'Disconnected';
                pssStatusElement.style.color = '#ef4444';
            }
        }
        
        // Update debug information
        function updateDebugInfo() {
            const lastUpdateElement = document.getElementById('last-update');
            if (lastUpdateTime) {
                lastUpdateElement.textContent = lastUpdateTime.toLocaleTimeString();
            }
        }
        
        // Handle PSS events from Tauri
        function handlePssEvent(event) {
            console.log('üì° Received PSS event:', event);
            console.log('üì° Event type:', event.type);
            console.log('üì° Full event structure:', JSON.stringify(event, null, 2));
            lastUpdateTime = new Date();
            
            if (!scoreboardInstance) {
                console.warn('‚ö†Ô∏è Scoreboard not initialized, ignoring event');
                return;
            }
            
            try {
                // Update connection status
                updateConnectionStatus(true);
                
                // ===== MANUAL OVERRIDE DETECTION INTEGRATION =====
                
                // Add event to recent events for pattern detection
                addToRecentEvents(event);
                
                // Update clock state tracking
                if (event.type === 'clock') {
                    if (event.action === 'start') {
                        manualOverrideState.clockState = 'running';
                        manualOverrideState.manualOverrideActive = false; // Exit manual override mode
                        console.log('üèÅ Exited manual override mode: clock started');
                    } else if (event.action === 'stop' || event.action === 'stopEnd') {
                        manualOverrideState.clockState = 'stopped';
                        manualOverrideState.manualOverrideActive = true; // Enter manual override mode
                        console.log('‚è∏Ô∏è Entered manual override mode: clock stopped');
                    }
                    manualOverrideState.lastClockTime = event.time;
                    manualOverrideState.lastClockAction = event.action;
                }
                
                // Check for manual overrides BEFORE normal processing
                let isManualOverride = false;
                
                // Check for manual time change
                if (isManualTimeChange(event)) {
                    handleManualTimeChange(event);
                    isManualOverride = true;
                }
                
                // Check for manual round change
                if (isManualRoundChange(event)) {
                    handleManualRoundChange(event);
                    isManualOverride = true;
                }
                
                // Check for manual score change (will be checked in individual handlers)
                // Check for manual warning change (will be checked in individual handlers)
                
                // Handle different event types
                switch (event.type) {
                    case 'athletes':
                        handleAthletesEvent(event);
                        break;
                    case 'match_config':
                        handleMatchConfigEvent(event);
                        break;
                    case 'current_scores':
                        handleScoresEvent(event);
                        break;
                    case 'fight_loaded':
                        handleFightLoadedEvent(event);
                        break;
                    case 'warnings':
                        handleWarningsEvent(event);
                        break;
                    case 'winner_rounds':
                        handleWinnerRoundsEvent(event);
                        break;
                    case 'winner':
                        handleMatchEndEvent(event);
                        break;
                    case 'clock':
                        handleClockEvent(event);
                        break;
                    case 'round':
                        handleRoundEvent(event);
                        break;
                    case 'supervision':
                        handleSupervisionEvent(event);
                        break;
                    case 'points':
                        handlePointsEvent(event);
                        break;
                    case 'fight_ready':
                        handleFightReadyEvent(event);
                        break;
                    case 'injury':
                        handleInjuryEvent(event);
                        break;
                    case 'raw':
                        handleRawEvent(event);
                        break;
                    default:
                        // Check if this is an injury event disguised as 'other' type
                        if (event.type === 'other' && (event.description?.includes('Injury') || event.event?.includes('Injury'))) {
                            console.log('ü©π Parsing injury event from other type:', event);
                            handleInjuryEventFromOther(event);
                        } else {
                            console.log('üìù Unhandled event type:', event.type);
                        }
                }
                
                updateDebugInfo();
                
            } catch (error) {
                console.error('‚ùå Error handling PSS event:', error);
            }
        }
        
        // Handle athletes event
        function handleAthletesEvent(event) {
            console.log('üë• Updating athletes:', event);
            
            // Try to parse raw_data first, then fall back to direct access
            let athleteData = null;
            
            if (event.raw_data) {
                try {
                    athleteData = JSON.parse(event.raw_data);
                    console.log('üë• Parsed raw_data:', athleteData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try direct access
            const data = athleteData || event;
            console.log('üë• Using data source:', athleteData ? 'raw_data' : 'direct');
            console.log('üë• athlete1:', data.athlete1);
            console.log('üë• athlete2:', data.athlete2);
            
            // Update player names - athlete1 maps to player1 (blue), athlete2 maps to player2 (red)
            if (data.athlete1 && data.athlete1.long) {
                console.log('‚úÖ Updating blue player name to:', data.athlete1.long);
                scoreboardInstance.updatePlayerName('blue', data.athlete1.long);
                document.getElementById('debug-blue').textContent = data.athlete1.long;
            } else {
                console.warn('‚ö†Ô∏è No athlete1.long found in event');
            }
            
            if (data.athlete2 && data.athlete2.long) {
                console.log('‚úÖ Updating red player name to:', data.athlete2.long);
                scoreboardInstance.updatePlayerName('red', data.athlete2.long);
                document.getElementById('debug-red').textContent = data.athlete2.long;
            } else {
                console.warn('‚ö†Ô∏è No athlete2.long found in event');
            }
            
            // Update countries - athlete1.country and athlete2.country are already IOC codes
            if (data.athlete1 && data.athlete1.country) {
                console.log('‚úÖ Updating blue player country to:', data.athlete1.country);
                scoreboardInstance.updateCountry('blue', data.athlete1.country);
            } else {
                console.warn('‚ö†Ô∏è No athlete1.country found in event');
            }
            
            if (data.athlete2 && data.athlete2.country) {
                console.log('‚úÖ Updating red player country to:', data.athlete2.country);
                scoreboardInstance.updateCountry('red', data.athlete2.country);
            } else {
                console.warn('‚ö†Ô∏è No athlete2.country found in event');
            }
        }
        
        // Handle match config event
        function handleMatchConfigEvent(event) {
            console.log('üèÜ Updating match config:', event);
            console.log('üèÜ Event type:', event.type);
            console.log('üèÜ Raw event:', JSON.stringify(event, null, 2));
            
            // Try to parse raw_data first, then fall back to structured_data
            let configData = null;
            
            if (event.raw_data) {
                try {
                    configData = JSON.parse(event.raw_data);
                    console.log('üèÜ Parsed raw_data:', configData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try structured_data
            const data = configData || event.structured_data || event;
            console.log('üèÜ Using data source:', configData ? 'raw_data' : 'structured_data');
            console.log('üèÜ Full data object:', JSON.stringify(data, null, 2));
            console.log('üèÜ weight:', data.weight);
            console.log('üèÜ division:', data.division);
            console.log('üèÜ category:', data.category);
            console.log('üèÜ number:', data.number);
            console.log('üèÜ round_duration:', data.round_duration);
            console.log('üèÜ round_duration type:', typeof data.round_duration);
            
            // Store round duration for clock resets
            if (data.round_duration !== undefined && data.round_duration !== null) {
                roundDuration = parseInt(data.round_duration);
                console.log('‚è∞ Stored round duration:', roundDuration, 'seconds');
                console.log('‚è∞ This should display as:', Math.floor(roundDuration / 60) + ':' + (roundDuration % 60).toString().padStart(2, '0'));
            } else {
                console.warn('‚ö†Ô∏è No round_duration found in match config event');
                console.warn('‚ö†Ô∏è Available keys:', Object.keys(data));
            }
            
            // Use the new combined method to update all match info at once
            if (data.weight || data.division || data.category) {
                console.log('‚úÖ Updating match info with:', data.weight, data.division, data.category);
                scoreboardInstance.updateMatchInfo(data.weight, data.division, data.category);
            } else {
                console.warn('‚ö†Ô∏è No weight, division, or category found in match config event');
            }
            
            if (data.number) {
                console.log('‚úÖ Updating match number to:', data.number);
                // Update match number in SVG
                const matchNumberElement = scoreboardInstance.svg.getElementById('matchNumber');
                if (matchNumberElement) {
                    matchNumberElement.textContent = `#${data.number}`;
                    console.log('‚úÖ Match number element updated');
                } else {
                    console.warn('‚ö†Ô∏è Could not find matchNumber element in SVG');
                }
            } else {
                console.warn('‚ö†Ô∏è No match number found in match config event');
            }
        }
        
        // Handle scores event
        function handleScoresEvent(event) {
            console.log('üìä Updating scores:', event);
            
            // Try to parse raw_data first, then fall back to direct access
            let scoreData = null;
            
            if (event.raw_data) {
                try {
                    scoreData = JSON.parse(event.raw_data);
                    console.log('üìä Parsed raw_data:', scoreData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try direct access
            const data = scoreData || event;
            console.log('üìä Using data source:', scoreData ? 'raw_data' : 'direct');
            
            // Check for both possible structures (nested and flat)
            let blueScore = 0;
            let redScore = 0;
            
            if (data.athlete1_score !== undefined && data.athlete2_score !== undefined) {
                // Flat structure (old format)
                blueScore = data.athlete1_score;
                redScore = data.athlete2_score;
                console.log('üìä Using flat structure for scores');
            } else if (data.athlete1 && data.athlete1.score !== undefined && data.athlete2 && data.athlete2.score !== undefined) {
                // Nested structure (new format)
                blueScore = data.athlete1.score;
                redScore = data.athlete2.score;
                console.log('üìä Using nested structure for scores');
            } else {
                console.warn('‚ö†Ô∏è No valid score structure found in event');
            }
            
            console.log('üìä Blue score:', blueScore, 'Red score:', redScore);
            
            // ===== MANUAL OVERRIDE DETECTION FOR SCORES =====
            
            // Check for manual score change
            if (isManualScoreChange(event, blueScore, redScore)) {
                console.log('üîÑ Manual score change detected, handling specially...');
                handleManualScoreChange(event, blueScore, redScore);
            } else {
                // Normal score update
                scoreboardInstance.updateScore('blue', blueScore);
                scoreboardInstance.updateScore('red', redScore);
            }
            
            // Update tracking state
            manualOverrideState.lastBlueScore = blueScore;
            manualOverrideState.lastRedScore = redScore;
            
            // Update debug info
            document.getElementById('debug-blue-score').textContent = blueScore;
            document.getElementById('debug-red-score').textContent = redScore;
        }
        
        // Handle fight loaded event
        function handleFightLoadedEvent(event) {
            console.log('ü•ä Fight loaded event:', event);
            updateConnectionStatus(true);
            
            // Apply typewriter effect for new match with correct round duration and current round
            if (scoreboardInstance) {
                setTimeout(() => {
                    // Get current round from event or default to 1
                    const currentRound = event.round || 1;
                    scoreboardInstance.applyNewMatchEffect(roundDuration, currentRound);
                }, 500); // Small delay to ensure all data is loaded
            }
        }
        
        // Handle warnings event
        function handleWarningsEvent(event) {
            console.log('‚ö†Ô∏è Warnings event:', event);
            
            // Try to parse raw_data first, then fall back to direct access
            let warningData = null;
            
            if (event.raw_data) {
                try {
                    warningData = JSON.parse(event.raw_data);
                    console.log('‚ö†Ô∏è Parsed raw_data:', warningData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try direct access
            const data = warningData || event;
            console.log('‚ö†Ô∏è Using data source:', warningData ? 'raw_data' : 'direct');
            
            // Check for both possible structures (nested and flat)
            let blueWarnings = 0;
            let redWarnings = 0;
            
            if (data.athlete1_warnings !== undefined && data.athlete2_warnings !== undefined) {
                // Flat structure (old format)
                blueWarnings = data.athlete1_warnings;
                redWarnings = data.athlete2_warnings;
                console.log('‚ö†Ô∏è Using flat structure for warnings');
            } else if (data.athlete1 && data.athlete1.warnings !== undefined && data.athlete2 && data.athlete2.warnings !== undefined) {
                // Nested structure (new format)
                blueWarnings = data.athlete1.warnings;
                redWarnings = data.athlete2.warnings;
                console.log('‚ö†Ô∏è Using nested structure for warnings');
            } else {
                console.warn('‚ö†Ô∏è No valid warnings structure found in event');
            }
            
            console.log('‚ö†Ô∏è Blue warnings:', blueWarnings, 'Red warnings:', redWarnings);
            
            // ===== MANUAL OVERRIDE DETECTION FOR WARNINGS =====
            
            // Check for manual warning change
            if (isManualWarningChange(event, blueWarnings, redWarnings)) {
                console.log('üîÑ Manual warning change detected, handling specially...');
                handleManualWarningChange(event, blueWarnings, redWarnings);
            } else {
                // Normal warning update
                // athlete1 maps to blue (player1), athlete2 maps to red (player2)
                if (blueWarnings !== undefined) {
                    scoreboardInstance.updatePenalties('blue', null, blueWarnings);
                }
                
                if (redWarnings !== undefined) {
                    scoreboardInstance.updatePenalties('red', null, redWarnings);
                }
            }
            
            // Update tracking state
            manualOverrideState.lastBlueWarnings = blueWarnings;
            manualOverrideState.lastRedWarnings = redWarnings;
        }
        
        // Handle winner rounds event
        function handleWinnerRoundsEvent(event) {
            console.log('üèÜ Winner rounds event:', event);
            
            // Try to parse raw_data first, then fall back to structured_data
            let winnerData = null;
            
            if (event.raw_data) {
                try {
                    winnerData = JSON.parse(event.raw_data);
                    console.log('üèÜ Parsed raw_data:', winnerData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try structured_data
            const data = winnerData || event.structured_data || event;
            console.log('üèÜ Using data source:', winnerData ? 'raw_data' : 'structured_data');
            console.log('üèÜ round1_winner:', data.round1_winner);
            console.log('üèÜ round2_winner:', data.round2_winner);
            console.log('üèÜ round3_winner:', data.round3_winner);
            
            // Reset current scores to 0:0 for new round
            scoreboardInstance.updateScore('blue', 0);
            scoreboardInstance.updateScore('red', 0);
            
            // Reset warnings to 0:0 for new round
            scoreboardInstance.updatePenalties('blue', null, 0);
            scoreboardInstance.updatePenalties('red', null, 0);
            
            // Update rounds won - athlete1 (player1/blue) = winner 1, athlete2 (player2/red) = winner 2
            if (data.round1_winner !== undefined) {
                const blueWins = (data.round1_winner === 1 ? 1 : 0) + 
                                (data.round2_winner === 1 ? 1 : 0) + 
                                (data.round3_winner === 1 ? 1 : 0);
                const redWins = (data.round1_winner === 2 ? 1 : 0) + 
                               (data.round2_winner === 2 ? 1 : 0) + 
                               (data.round3_winner === 2 ? 1 : 0);
                
                console.log(`üèÜ Updating round wins - Blue: ${blueWins}, Red: ${redWins}`);
                scoreboardInstance.updateRoundWins('blue', blueWins);
                scoreboardInstance.updateRoundWins('red', redWins);
            } else {
                console.warn('‚ö†Ô∏è No round winners found in event data');
            }
        }
        
        // Handle match end event (when winner is announced)
        function handleMatchEndEvent(event) {
            console.log('üèÅ Match end event:', event);
            
            // Update final scores and winner information
            if (event.winner) {
                console.log(`üèÜ Match winner: ${event.winner}`);
                // You can add winner announcement logic here
            }
        }
        
        // Handle clock event
        function handleClockEvent(event) {
            console.log('‚è∞ Clock event:', event);
            
            if (event.time) {
                // Parse time in format "m:ss" or "ss"
                let minutes = 0;
                let seconds = 0;
                
                if (event.time.includes(':')) {
                    const parts = event.time.split(':');
                    minutes = parseInt(parts[0]) || 0;
                    seconds = parseInt(parts[1]) || 0;
                } else {
                    seconds = parseInt(event.time) || 0;
                }
                
                scoreboardInstance.updateTimer(minutes, seconds);
            }
        }
        
        // Handle round event
        function handleRoundEvent(event) {
            console.log('üîÑ Round event:', event);
            console.log('üîÑ Current roundDuration variable:', roundDuration);
            
            // Try to parse raw_data first, then fall back to structured_data
            let roundData = null;
            
            if (event.raw_data) {
                try {
                    roundData = JSON.parse(event.raw_data);
                    console.log('üîÑ Parsed raw_data:', roundData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try structured_data
            const data = roundData || event.structured_data || event;
            console.log('üîÑ Using data source:', roundData ? 'raw_data' : 'structured_data');
            
            // Get round number from various possible sources
            let roundNumber = null;
            if (data.current_round !== undefined) {
                roundNumber = data.current_round;
                console.log('üîÑ Found round in current_round field:', roundNumber);
            } else if (data.round !== undefined) {
                roundNumber = data.round;
                console.log('üîÑ Found round in round field:', roundNumber);
            } else if (event.round !== undefined) {
                roundNumber = event.round;
                console.log('üîÑ Found round in event.round field:', roundNumber);
            }
            
            if (roundNumber !== null) {
                // ===== MANUAL OVERRIDE DETECTION FOR ROUND CHANGES =====
                
                // Check if this is a manual round change
                if (isManualRoundChange(event)) {
                    console.log('üîÑ Manual round change detected, preserving all data...');
                    handleManualRoundChange(event);
                } else {
                    // Normal round change - update round and reset clock
                    scoreboardInstance.updateRound(roundNumber);
                    console.log(`üîÑ Updated to round: ${roundNumber} (normal change)`);
                    
                    // Reset clock using stored round duration
                    const minutes = Math.floor(roundDuration / 60);
                    const seconds = roundDuration % 60;
                    console.log(`‚è∞ Resetting clock with roundDuration=${roundDuration}s -> ${minutes}:${seconds.toString().padStart(2, '0')}`);
                    scoreboardInstance.updateTimer(minutes, seconds);
                    console.log(`‚è∞ Reset clock to ${minutes}:${seconds.toString().padStart(2, '0')} for new round`);
                }
            } else {
                console.warn('‚ö†Ô∏è No round number found in round event:', event);
            }
        }
        
        // Handle points event
        function handlePointsEvent(event) {
            console.log('üéØ Points event:', event);
            
            // Try to parse raw_data first, then fall back to structured_data
            let pointsData = null;
            
            if (event.raw_data) {
                try {
                    pointsData = JSON.parse(event.raw_data);
                    console.log('üéØ Parsed raw_data:', pointsData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try structured_data
            const data = pointsData || event.structured_data || event;
            console.log('üéØ Using data source:', pointsData ? 'raw_data' : 'structured_data');
            
            // Check for manual score change
            if (isManualScoreChange(event, manualOverrideState.lastBlueScore, manualOverrideState.lastRedScore)) {
                console.log('üîÑ Manual points change detected, handling specially...');
                // The actual score update will be handled by the scores event
                // This is just for detection and logging
            }
        }
        
        // Handle supervision event (warnings reset)
        function handleSupervisionEvent(event) {
            console.log('üëÅÔ∏è Supervision event:', event);
            
            // Try to parse raw_data first, then fall back to structured_data
            let supervisionData = null;
            
            if (event.raw_data) {
                try {
                    supervisionData = JSON.parse(event.raw_data);
                    console.log('üëÅÔ∏è Parsed raw_data:', supervisionData);
                } catch (error) {
                    console.error('‚ùå Failed to parse raw_data:', error);
                }
            }
            
            // Use parsed data if available, otherwise try structured_data
            const data = supervisionData || event.structured_data || event;
            console.log('üëÅÔ∏è Using data source:', supervisionData ? 'raw_data' : 'structured_data');
            
            // Check for supervision value (0 = reset warnings)
            let supervisionValue = 0;
            
            if (data.value !== undefined) {
                supervisionValue = data.value;
            } else if (data.supervision !== undefined) {
                supervisionValue = data.supervision;
            }
            
            console.log('üëÅÔ∏è Supervision value:', supervisionValue);
            
            // If supervision is 0, reset warnings
            if (supervisionValue === 0) {
                console.log('üîÑ Resetting warnings due to supervision event');
                scoreboardInstance.updatePenalties('blue', null, 0);
                scoreboardInstance.updatePenalties('red', null, 0);
            }
        }
        
        // Handle fight ready event
        function handleFightReadyEvent(event) {
            console.log('ü•ä Fight ready event:', event);
            updateConnectionStatus(true);
            
            // Apply typewriter effect for new match with correct round duration and current round
            if (scoreboardInstance) {
                setTimeout(() => {
                    // Get current round from event or default to 1
                    const currentRound = event.round || 1;
                    scoreboardInstance.applyNewMatchEffect(roundDuration, currentRound);
                }, 500); // Small delay to ensure all data is loaded
            }
        }
        
        // Handle injury event (for properly typed events)
        function handleInjuryEvent(event) {
            console.log('ü©π Injury event:', event);
            
            if (event.time !== undefined) {
                scoreboardInstance.updateInjuryTime(event.time);
            }
            
            if (event.action) {
                if (event.action === 'show') {
                    scoreboardInstance.showInjurySection();
                } else if (event.action === 'hide') {
                    scoreboardInstance.hideInjurySection();
                } else if (event.action === 'reset') {
                    scoreboardInstance.resetInjuryTime();
                }
            }
        }
        
        // Handle injury event from 'other' type (parsing from description/event string)
        function handleInjuryEventFromOther(event) {
            console.log('ü©π Parsing injury event from other type:', event);
            
            // Extract injury data from description or event string
            const injuryString = event.description || event.event || '';
            
            // Parse the injury data using regex
            const injuryMatch = injuryString.match(/Injury\s*\{\s*athlete:\s*(\d+),\s*time:\s*"([^"]+)",\s*action:\s*(Some\("([^"]+)"\)|None)\s*\}/);
            
            if (injuryMatch) {
                const athlete = parseInt(injuryMatch[1]);
                const time = injuryMatch[2];
                const actionRaw = injuryMatch[3];
                const action = injuryMatch[4] || null; // Extract from Some("action") or null
                
                console.log('ü©π Parsed injury data:', { athlete, time, action });
                
                // Update injury time
                if (time) {
                    scoreboardInstance.updateInjuryTime(time);
                }
                
                // Handle action
                if (action === 'show') {
                    scoreboardInstance.showInjurySection();
                    console.log('‚úÖ Showing injury section');
                } else if (action === 'hide') {
                    scoreboardInstance.hideInjurySection();
                    console.log('‚úÖ Hiding injury section');
                } else if (action === 'reset') {
                    scoreboardInstance.resetInjuryTime();
                    console.log('‚úÖ Resetting injury time');
                } else if (action === null) {
                    // Just update the time without changing visibility
                    console.log('‚úÖ Updated injury time only');
                }
            } else {
                console.warn('‚ö†Ô∏è Could not parse injury data from string:', injuryString);
            }
        }
        
        // Handle raw PSS events (for backward compatibility)
        function handleRawEvent(event) {
            console.log('üìù Raw PSS event:', event);
            
            if (!event.message) return;
            
            // Parse raw match config (mch;) lines
            if (event.message.startsWith('mch;')) {
                try {
                    const parts = event.message.split(';');
                    const matchConfig = {
                        number: parseInt(parts[1]) || 0,
                        category: parts[2] || '',
                        weight: parts[3]?.replace(/\s+/g, '') || '',
                        division: parts[10] || '',
                    };
                    
                    handleMatchConfigEvent(matchConfig);
                } catch (error) {
                    console.error('‚ùå Error parsing raw mch line:', error);
                }
            }
            
            // Parse warnings (wg1;wg2;) lines
            else if (event.message.includes('wg1;') && event.message.includes('wg2;')) {
                try {
                    const parts = event.message.split(';');
                    const warnings = {
                        athlete1_warnings: parseInt(parts[1]) || 0,
                        athlete2_warnings: parseInt(parts[3]) || 0,
                        type: 'warnings'
                    };
                    
                    handleWarningsEvent(warnings);
                } catch (error) {
                    console.error('‚ùå Error parsing raw warnings line:', error);
                }
            }
            
            // Parse winner rounds (wrd;) lines
            else if (event.message.startsWith('wrd;')) {
                try {
                    const parts = event.message.split(';');
                    const winnerRounds = {
                        round1_winner: parseInt(parts[2]) || 0,
                        round2_winner: parseInt(parts[4]) || 0,
                        round3_winner: parseInt(parts[6]) || 0,
                        type: 'winner_rounds'
                    };
                    
                    handleWinnerRoundsEvent(winnerRounds);
                } catch (error) {
                    console.error('‚ùå Error parsing raw winner rounds line:', error);
                }
            }
            
            // Parse clock (clk;) lines
            else if (event.message.startsWith('clk;')) {
                try {
                    const parts = event.message.split(';');
                    const clock = {
                        time: parts[1] || '0:00',
                        action: parts[2] || null,
                        type: 'clock'
                    };
                    
                    handleClockEvent(clock);
                } catch (error) {
                    console.error('‚ùå Error parsing raw clock line:', error);
                }
            }
            
            // Parse round (rnd;) lines
            else if (event.message.startsWith('rnd;')) {
                try {
                    const parts = event.message.split(';');
                    const round = {
                        current_round: parseInt(parts[1]) || 1,
                        type: 'round'
                    };
                    
                    handleRoundEvent(round);
                } catch (error) {
                    console.error('‚ùå Error parsing raw round line:', error);
                }
            }
            
            // Parse fight ready (rdy;) lines
            else if (event.message.startsWith('rdy;')) {
                try {
                    const parts = event.message.split(';');
                    const fightReady = {
                        status: parts[1] || 'FightReady',
                        type: 'fight_ready'
                    };
                    
                    handleFightReadyEvent(fightReady);
                } catch (error) {
                    console.error('‚ùå Error parsing raw fight ready line:', error);
                }
            }
            
            // Parse scores (sc1;sc2;) lines
            else if (event.message.includes('sc1;') && event.message.includes('sc2;')) {
                try {
                    const parts = event.message.split(';');
                    const scores = {
                        athlete1_score: parseInt(parts[1]) || 0,
                        athlete2_score: parseInt(parts[3]) || 0,
                        type: 'current_scores'
                    };
                    
                    console.log(`üìä Parsed score message: ${event.message}`);
                    console.log(`üìä Parts:`, parts);
                    console.log(`üìä Scores: blue=${scores.athlete1_score}, red=${scores.athlete2_score}`);
                    console.log(`üìä Scoreboard instance:`, scoreboardInstance);
                    
                    handleScoresEvent(scores);
                } catch (error) {
                    console.error('‚ùå Error parsing raw scores line:', error);
                }
            }
            
            // Parse structured current_scores events from WebSocket
            else if (event.type === 'current_scores') {
                try {
                    const scores = {
                        athlete1_score: event.athlete1_score || event.structured_data?.athlete1_score || 0,
                        athlete2_score: event.athlete2_score || event.structured_data?.athlete2_score || 0,
                        type: 'current_scores'
                    };
                    
                    console.log(`üìä Parsed structured current_scores: blue=${scores.athlete1_score}, red=${scores.athlete2_score}`);
                    handleScoresEvent(scores);
                } catch (error) {
                    console.error('‚ùå Error parsing structured current_scores:', error);
                }
            }
            
            // Parse supervision (sv;) lines
            else if (event.message.startsWith('sv;')) {
                try {
                    const parts = event.message.split(';');
                    const supervision = {
                        value: parseInt(parts[1]) || 0,
                        type: 'supervision'
                    };
                    
                    handleSupervisionEvent(supervision);
                } catch (error) {
                    console.error('‚ùå Error parsing raw supervision line:', error);
                }
            }
            
            // Parse injury time (ij1;, ij2;, ij0;) lines
            else if (event.message.startsWith('ij1;') || event.message.startsWith('ij2;') || event.message.startsWith('ij0;')) {
                try {
                    const parts = event.message.split(';');
                    const athlete = event.message.startsWith('ij1;') ? 1 : 
                                  event.message.startsWith('ij2;') ? 2 : 0;
                    const time = parts[1] || '0:00';
                    const action = parts[2] || null;
                    
                    const injury = {
                        athlete: athlete,
                        time: time,
                        action: action,
                        type: 'injury'
                    };
                    
                    handleInjuryEvent(injury);
                } catch (error) {
                    console.error('‚ùå Error parsing raw injury line:', error);
                }
            }
        }
        
        // WebSocket connection for real-time PSS events
        let websocket = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const reconnectDelay = 2000;
        
        function setupWebSocketConnection() {
            console.log('üîó Setting up WebSocket connection...');
            
            try {
                // Get WebSocket URL from current location or use default
                const currentHost = window.location.hostname;
                const wsHost = currentHost === 'localhost' || currentHost === '127.0.0.1' ? '127.0.0.1' : currentHost;
                const wsUrl = `ws://${wsHost}:3001`;
                
                console.log(`üîó Connecting to WebSocket server at: ${wsUrl}`);
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = function(event) {
                    console.log('‚úÖ WebSocket connected to reStrike VTA server');
                    updateConnectionStatus(true);
                    reconnectAttempts = 0;
                    
                    // Send ping to keep connection alive
                    setInterval(() => {
                        if (websocket.readyState === WebSocket.OPEN) {
                            websocket.send('ping');
                        }
                    }, 30000);
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('üì° WebSocket message received:', data);
                        console.log('üì° Raw WebSocket data:', event.data);
                        
                        if (data.type === 'pss_event') {
                            console.log('üéØ PSS event received via WebSocket:', data.data.type);
                            console.log('üéØ PSS event data:', data.data);
                            handlePssEvent(data.data);
                        } else if (data.type === 'connection') {
                            console.log('üîó Connection confirmed:', data.message);
                        } else {
                            console.log('üì° Other WebSocket message type:', data.type);
                        }
                    } catch (error) {
                        console.error('‚ùå Error parsing WebSocket message:', error);
                        console.error('‚ùå Raw message was:', event.data);
                    }
                };
                
                websocket.onclose = function(event) {
                    console.log('üîå WebSocket connection closed');
                    updateConnectionStatus(false);
                    
                    // Attempt to reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        console.log(`üîÑ Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                        setTimeout(setupWebSocketConnection, reconnectDelay);
                    } else {
                        console.error('‚ùå Max reconnection attempts reached, falling back to localStorage');
                        setupFallbackEventSystem();
                    }
                };
                
                websocket.onerror = function(error) {
                    console.error('‚ùå WebSocket error:', error);
                    updateConnectionStatus(false);
                };
                
            } catch (error) {
                console.error('‚ùå Failed to setup WebSocket connection:', error);
                setupFallbackEventSystem();
            }
        }
        
        // Fallback event system for testing
        function setupFallbackEventSystem() {
            console.log('üîÑ Setting up fallback event system...');
            
            // Listen for custom events (for testing)
            window.addEventListener('pss-event', (event) => {
                console.log('üì° Fallback PSS event received:', event.detail);
                handlePssEvent(event.detail);
            });
            
            // Listen for broadcasted events via localStorage
            window.addEventListener('storage', (e) => {
                if (e.key === 'pss_event' && e.newValue) {
                    try {
                        const eventData = JSON.parse(e.newValue);
                        if (eventData.type === 'pss_event') {
                            console.log('üì° Received broadcasted PSS event:', eventData.data);
                            handlePssEvent(eventData.data);
                        }
                    } catch (error) {
                        console.error('‚ùå Error parsing broadcasted event:', error);
                    }
                }
            });
            
            // Simulate connection for testing
            setTimeout(() => {
                updateConnectionStatus(true);
                console.log('‚úÖ Fallback event system ready');
            }, 2000);
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Scoreboard overlay page loaded');
            
            // Check if scripts are loaded
            console.log('üîç Checking script availability...');
            console.log('üîç ScoreboardOverlay available:', typeof ScoreboardOverlay !== 'undefined');
            console.log('üîç ScoreboardNameManager available:', typeof ScoreboardNameManager !== 'undefined');
            
            // Initialize scoreboard when SVG loads
            const svgObject = document.getElementById('scoreboard-svg');
            svgObject.addEventListener('load', initializeScoreboard);
            
            // Setup WebSocket connection for real-time PSS events
            setupWebSocketConnection();
            
            // Initialize immediately if SVG is already loaded
            if (svgObject.contentDocument) {
                initializeScoreboard();
            }
        });
        
        // Cleanup when page is unloaded
        window.addEventListener('beforeunload', () => {
            console.log('üßπ Cleaning up dramatic countdown...');
            // No dramatic countdown to clean up
        });
        
        // Export functions for external access
        window.ScoreboardOverlayManager = {
            handlePssEvent,
            updateConnectionStatus,
            scoreboardInstance: () => scoreboardInstance,
            nameManager: () => nameManager
        };
        
        console.log('üéØ Scoreboard overlay script loaded');
    </script>
</body>
</html> 