# reStrike VTA - Windows-Only Project Context Rules

## Latest Development Status (2025-01-29):
- ✅ Windows-only, production-ready, Rust+React (Tauri) application
- ✅ Docker/devcontainer fully removed from all onboarding, docs, and scripts
- ✅ Modular, plugin-based Rust backend (AppResult/AppError, crate naming, import style)
- ✅ React 18 frontend with IOC flag system, advanced UI/UX
- ✅ All onboarding, build, and documentation reference Windows-native setup only
- ✅ Project structure, naming, and maintenance conventions are strictly enforced (see below)
- ✅ Performance best practices for both frontend and backend are required
- ✅ **Tab System Infrastructure**: Reusable Tab and TabGroup components with flat styling
- ✅ **Flag Management System**: Complete implementation with 253+ IOC flags and PSS code mapping
- ✅ **Database Integration**: Complete PSS and UDP subsystem integration with maximally normalized tables
- ✅ **Documentation Consolidation**: 6 main consolidated documents in `docs/architecture/` as single source of truth

---

## 1. File/Directory Structure
- All documentation is organized by category in `docs/` (api, development, project, requirements, integration, etc.)
- All scripts are grouped by purpose in `scripts/` (development, obs, project, media, workflows)
- Rust backend is modular: plugins in `src/plugins/`, commands in `src/commands/`, core logic in `src/core/`
- React frontend is in `ui/` with assets, components, hooks, stores, utils, and config
- Root directory contains only essential files (Cargo.toml, package.json, README.md, etc.)
- All navigation indexes (docs/README.md, scripts/README.md) must be kept up to date
- **Flag assets**: 253+ IOC flags stored in `ui/public/assets/flags/`
- **Tab components**: Reusable Tab and TabGroup in `ui/src/components/atoms/`
- **Main Documentation**: 6 consolidated files in `docs/architecture/`:
  - `docs/architecture/DATABASE_INTEGRATION_GUIDE.md` - Database structure, models, relationships, and integration
  - `docs/architecture/BACKEND_ARCHITECTURE.md` - Backend structure, plugin system, and core systems
  - `docs/architecture/FRONTEND_ARCHITECTURE.md` - Frontend structure, component architecture, and UI system
  - `docs/architecture/DATA_FLOW_ARCHITECTURE.md` - Data flow patterns and system integration
  - `docs/architecture/LAYER_WIRING_DIAGRAM.md` - Layer connections, dependencies, and communication patterns
  - `docs/architecture/UI_DESIGN_GUIDELINES.md` - UI development guidelines, component system, and design patterns

## 2. Naming Conventions
- **Documentation**: `kebab-case.md` (e.g., `container-restart.md`, `software-requirements.md`)
- **Scripts**: `kebab-case.sh` or `kebab-case.py`, grouped in subdirectories by purpose
- **Rust Source**: `snake_case.rs` for modules, `PascalCase` for types/structs/enums, `camelCase` for functions/variables
- **React/TS**: `PascalCase.tsx` for components, `camelCase.ts` for utilities
- **Configuration**: `kebab-case.json` or `kebab-case.toml`

## 3. Maintenance Guidelines
- All new files must follow category and naming conventions
- When moving files, update all imports, documentation links, and configuration paths
- Test all functionality after structural changes
- Monthly structure reviews are required; remove obsolete files and consolidate similar ones
- Keep navigation indexes and cross-references current
- All documentation and onboarding must reference this file and be updated after any major change
- **Preservation Before Deletion/Refactor**: Before deleting or refactoring any file, always copy the code to a backup file (e.g., .copy or .bak extension) to preserve the existing code, then proceed with deletion or refactor. This ensures no code is lost and allows for easy rollback if needed.
- **Documentation Consolidation**: Regularly consolidate duplicate documentation and remove obsolete files
- **Main Documentation Rule**: ALWAYS update the 6 main documentation files instead of creating new .md files. These are the single source of truth for all project documentation.
- **Documentation Management Rule**: When adding new information or making changes to project architecture, components, or systems, ALWAYS update the appropriate main documentation file:
  - Database changes → Update `docs/architecture/DATABASE_INTEGRATION_GUIDE.md`
  - Backend changes → Update `docs/architecture/BACKEND_ARCHITECTURE.md`
  - Frontend changes → Update `docs/architecture/FRONTEND_ARCHITECTURE.md`
  - Data flow changes → Update `docs/architecture/DATA_FLOW_ARCHITECTURE.md`
  - Layer wiring changes → Update `docs/architecture/LAYER_WIRING_DIAGRAM.md`
  - UI/UX changes → Update `docs/architecture/UI_DESIGN_GUIDELINES.md`
  - NEVER create new standalone .md files for information that belongs in these main documents

## 📋 Documentation Update Rules by Task Category

### **Database & Data Management Tasks**
**When to Update**: Any database schema changes, new tables, migrations, data models, or database operations
**Primary Document**: `docs/architecture/DATABASE_INTEGRATION_GUIDE.md`
**Update Content**:
- Add new table definitions and relationships
- Document migration changes and version updates
- Update data model descriptions
- Add new database operations and methods
- Document performance optimizations
- Update normalization strategies

**Examples**:
- "Add new PSS event table" → Update DATABASE_INTEGRATION_GUIDE.md
- "Optimize database queries" → Update DATABASE_INTEGRATION_GUIDE.md
- "Add new migration" → Update DATABASE_INTEGRATION_GUIDE.md

### **Backend & Rust Development Tasks**
**When to Update**: Any Rust code changes, plugin modifications, new Tauri commands, or backend architecture changes
**Primary Document**: `docs/architecture/BACKEND_ARCHITECTURE.md`
**Update Content**:
- Document new plugins and their functionality
- Update plugin architecture descriptions
- Add new Tauri commands and their purposes
- Document error handling patterns
- Update async operation patterns
- Document shared state management changes

**Examples**:
- "Add new UDP plugin" → Update BACKEND_ARCHITECTURE.md
- "Implement new Tauri command" → Update BACKEND_ARCHITECTURE.md
- "Fix error handling in plugin" → Update BACKEND_ARCHITECTURE.md

### **Frontend & React Development Tasks**
**When to Update**: Any React component changes, UI state management, new components, or frontend architecture changes
**Primary Document**: `docs/architecture/FRONTEND_ARCHITECTURE.md`
**Update Content**:
- Document new components and their hierarchy
- Update atomic design system descriptions
- Add new state management patterns
- Document component integration patterns
- Update UI patterns and conventions
- Document new hooks or utilities

**Examples**:
- "Add new React component" → Update FRONTEND_ARCHITECTURE.md
- "Implement new Zustand store" → Update FRONTEND_ARCHITECTURE.md
- "Update atomic design system" → Update FRONTEND_ARCHITECTURE.md

### **Data Flow & Event Processing Tasks**
**When to Update**: Any changes to data flow, event processing, real-time communication, or system integration patterns
**Primary Document**: `docs/architecture/DATA_FLOW_ARCHITECTURE.md`
**Update Content**:
- Document new event types and processing
- Update data flow diagrams and descriptions
- Add new integration patterns
- Document real-time communication changes
- Update event handling strategies
- Document data transformation patterns

**Examples**:
- "Add new PSS event type" → Update DATA_FLOW_ARCHITECTURE.md
- "Implement real-time event streaming" → Update DATA_FLOW_ARCHITECTURE.md
- "Update UDP event processing" → Update DATA_FLOW_ARCHITECTURE.md

### **System Architecture & Layer Wiring Tasks**
**When to Update**: Any changes to system architecture, layer connections, dependencies, or component relationships
**Primary Document**: `docs/architecture/LAYER_WIRING_DIAGRAM.md`
**Update Content**:
- Update layer connection diagrams
- Document new dependencies and relationships
- Add new architectural patterns
- Update component interaction patterns
- Document new integration points
- Update system boundaries and interfaces

**Examples**:
- "Add new system layer" → Update LAYER_WIRING_DIAGRAM.md
- "Update plugin dependencies" → Update LAYER_WIRING_DIAGRAM.md
- "Implement new integration pattern" → Update LAYER_WIRING_DIAGRAM.md

### **UI/UX & Design System Tasks**
**When to Update**: Any UI design changes, styling updates, component styling, or design system modifications
**Primary Document**: `docs/architecture/UI_DESIGN_GUIDELINES.md`
**Update Content**:
- Document new design patterns and components
- Update styling guidelines and conventions
- Add new UI patterns and interactions
- Document theme system changes
- Update accessibility guidelines
- Document responsive design patterns

**Examples**:
- "Add new UI component" → Update UI_DESIGN_GUIDELINES.md
- "Update color scheme" → Update UI_DESIGN_GUIDELINES.md
- "Implement new design pattern" → Update UI_DESIGN_GUIDELINES.md

### **Cross-Cutting Concerns**
**When to Update**: Tasks that affect multiple areas or have system-wide impact
**Primary Documents**: Update ALL relevant main documents
**Update Strategy**:
- Identify all affected areas
- Update each relevant main document
- Ensure consistency across documents
- Cross-reference related changes

**Examples**:
- "Implement new feature affecting frontend and backend" → Update both FRONTEND_ARCHITECTURE.md and BACKEND_ARCHITECTURE.md
- "Add new system-wide configuration" → Update multiple relevant documents
- "Implement new authentication system" → Update BACKEND_ARCHITECTURE.md, DATA_FLOW_ARCHITECTURE.md, and UI_DESIGN_GUIDELINES.md

### **Documentation Update Process**
1. **Identify Task Category**: Determine which category the task belongs to
2. **Select Primary Document**: Choose the main document to update based on the category
3. **Update Content**: Add relevant information to the appropriate sections
4. **Cross-Reference**: Update related documents if the change affects multiple areas
5. **Maintain Consistency**: Ensure all documents remain consistent and up-to-date

### **Update Priority Rules**
- **High Priority**: Core architecture changes, new features, breaking changes
- **Medium Priority**: Enhancements, optimizations, bug fixes with architectural impact
- **Low Priority**: Minor updates, documentation improvements, formatting changes

### **Update Frequency**
- **Immediate**: After completing any architectural change or new feature
- **Weekly**: Review and update documentation for accumulated changes
- **Monthly**: Comprehensive review and consolidation of all documentation

## 4. Performance Best Practices
- **Frontend**:
  - Disable source maps in development (`GENERATE_SOURCEMAP=false`)
  - Use Fast Refresh and React.memo for components
  - Disable StrictMode in development for faster renders
  - Optimize imports and bundle size
  - Use fast build/dev scripts (`npm run build:fast`, `npm run start:fast`)
  - Clean caches regularly (`npm run clean:all`)
  - Monitor bundle size (`npm run analyze`)
- **Backend (Rust)**:
  - Use optimized dev profile: `opt-level=1`, `codegen-units=256`, `incremental=true`, `lto=false`
  - Enable incremental compilation and debug assertions
  - Use `./scripts/development/fast-dev.sh` for fast dev cycles
  - Clean build artifacts regularly (`cargo clean`)
  - Monitor build times and optimize as needed
- **General**:
  - Always use fast scripts for development
  - Clean caches and artifacts weekly or when performance degrades
  - Review and optimize imports and dependencies regularly

---

## 5. Single Source of Truth
- This file (`.cursor/rules/context.mdc`) is the **single source of truth** for all project architecture, onboarding, coding, structure, naming, maintenance, and performance conventions.
- All onboarding, build, and documentation must reference this file and be updated after any major change.
- All team members must follow these conventions when adding or modifying files.
- **Main Documentation**: The 6 consolidated documentation files are the single source of truth for their respective domains.

---

_Last updated: 2025-01-29_

## 🖥️ Windows-Only Native Application
- This project is a **native Windows desktop application** (no Docker/devcontainer).
- All development, build, and deployment targets Windows 10/11 (x64).
- Production deployment is via Windows .exe and MSI installer (no containerization).

## 📚 Required Documentation Context
- **ALWAYS include:**
  - `docs/architecture/` (6 main consolidated documents - CRITICAL)
  - `README.md` (project overview)
  - `.cursor/rules/context.mdc` (this file - CRITICAL)
  - Previous chat history for continuity

## 🏗️ Architecture & Conventions

### **Database Architecture**
- **SQLite Database**: Single-file database with comprehensive schema
- **Maximal Normalization**: All tables follow 3NF principles
- **PSS Integration**: Complete Protocol Scoring System integration with UDP events
- **Key Tables**:
  - `network_interfaces` - Network interface management
  - `udp_server_configs` - UDP server configuration
  - `udp_server_sessions` - Session tracking
  - `udp_client_connections` - Client connection management
  - `pss_event_types` - Event type definitions
  - `pss_matches` - Match information
  - `pss_athletes` - Athlete data
  - `pss_events_v2` - Event storage with raw and parsed data
  - `pss_event_details` - Detailed event information
  - `pss_scores` - Score tracking
  - `pss_warnings` - Warning management
- **Migration System**: Custom migration strategy with version tracking
- **Performance**: In-memory caching for frequently accessed data

### **Backend Architecture**
- **Rust (Tauri plugin architecture, modular, plugin-based)**
  - All plugin/core methods use `AppResult<T>` and propagate errors as `AppError`.
  - `AppError::IoError` is ONLY for `std::io::Error`.
  - Custom error messages use `AppError::ConfigError` or other appropriate variant.
  - **Import conventions:**
    - Use `plugins::plugin_obs` NOT `obs` (after reorganization)
    - All plugins are under `src/plugins/` module
    - Core modules: `core::`, `config::`, `logging::`, `types::`
  - **Plugin System**:
    - `DatabasePlugin` - Database operations and migrations
    - `UdpPlugin` - UDP server and PSS event handling
    - `ObsPlugin` - OBS Studio integration
    - `CpuMonitorPlugin` - System monitoring
    - `LicensePlugin` - License management
  - **Error handling:**
    - When returning errors to API responses expecting `Option<String>`, use `e.to_string()`
    - When converting `std::io::Error` to `AppError`, use `AppError::IoError(e)`
    - When converting `std::io::Error` to `AppError::ConfigError`, use `AppError::ConfigError(e.to_string())`
  - **Async Operations**: Tokio-based async/await for database operations
  - **Shared State**: Arc<Mutex<T>> for thread-safe access to shared resources

### **Frontend Architecture**
- **React 18 + TypeScript + Tailwind CSS**
  - **Atomic Design System**: Complete component hierarchy (atoms, molecules, organisms, layouts)
  - **Tab System**: Reusable Tab and TabGroup components with flat styling
  - **Flag Management**: Complete system with 253+ IOC flags and PSS code mapping
  - **State Management**: Zustand for global state management
  - **Environment Detection**: Smart Tauri vs Web mode detection
  - **Component Structure**:
    - Atoms: Button, Input, Checkbox, Label, StatusDot, Icon, Tab, TabGroup
    - Molecules: EventTableSection, LiveDataPanel, CpuMonitoringSection, FlagManagementPanel
    - Organisms: EventTable, MatchInfoSection, ObsWebSocketManager, SidebarSmall, SidebarBig
    - Layouts: DockBar, AdvancedPanel, StatusbarAdvanced
  - **UI Design System**:
    - Modern gradient style: `bg-gradient-to-br from-gray-800/80 to-gray-900/90 backdrop-blur-sm rounded-lg border border-gray-600/30 shadow-lg`
    - Color system: Blue-300 for headings, gray-300 for body text, semantic colors for status
    - Typography: Inter font stack with semantic hierarchy
    - Responsive design: Tailwind breakpoints with adaptive layouts

### **Data Flow Architecture**
- **PSS Event Processing**: UDP → Parse → Validate → Store → UI Update
- **Real-time Events**: Event-driven architecture with Tauri events
- **Database Operations**: Async operations with caching for performance
- **State Synchronization**: Frontend-backend state synchronization via Tauri commands
- **Error Handling**: Comprehensive error propagation and user feedback

### **Layer Wiring**
- **Presentation Layer**: React components with Tauri integration
- **Bridge Layer**: Tauri commands and events for IPC
- **Application Layer**: Plugin system with shared state management
- **Plugin Layer**: Modular plugins for specific functionality
- **Data Layer**: SQLite database with migration system

## 🎨 UI Development Guidelines
- **UI Work Boundaries**: ONLY modify UI files (React components, styling)
- **Never Touch**: Backend code, Tauri configuration, or permissions during UI work
- **Safe to Modify**: `ui/src/components/`, `ui/src/App.tsx`, `ui/src/stores/`, Tailwind CSS
- **Tab System**: Use reusable Tab and TabGroup components with flat styling
- **Flag Integration**: All systems use flags from `ui/public/assets/flags/`
- **PSS Code Mapping**: Simplified system where PSS codes = IOC codes

### **Table Design Rules**
- **Sticky Headers**: All scrollable tables (with `max-h-*` and `overflow-y-auto`) MUST have sticky headers
- **Header Classes**: Use `sticky top-0 z-10` on `<thead>` elements for fixed headers when scrolling
- **Consistent Styling**: All tables use `bg-[#101820]` for header background and `text-gray-200` for text
- **Container Structure**: Use `max-h-64 overflow-y-auto border border-gray-700 rounded` for scrollable table containers
- **Row Hover**: Use `hover:bg-blue-900 transition-colors` for table row hover effects

### **Unified Theme System**
- **Modern Gradient Style**: Use `bg-gradient-to-br from-gray-800/80 to-gray-900/90 backdrop-blur-sm rounded-lg border border-gray-600/30 shadow-lg` for all panels and containers
- **Legacy Style (Deprecated)**: `bg-gray-800 rounded-lg` should be replaced with the modern gradient style
- **Consistent Borders**: Use `border-gray-600/30` for all borders with the modern gradient style
- **Text Colors**: Use `text-blue-300` for headings, `text-gray-300` for labels, `text-gray-400` for secondary text
- **Status Indicators**: Use `bg-green-900 text-green-300` for success, `bg-yellow-900 text-yellow-300` for warnings, `bg-red-900 text-red-300` for errors
- **Interactive Elements**: Use `bg-gray-700/30 rounded border border-gray-600/20` for interactive containers within panels

## 🚀 Recent Major Updates (2025-01-29)
- **Database Integration**: Complete PSS and UDP subsystem integration with maximally normalized tables
- **Documentation Consolidation**: 6 main consolidated documents in `docs/architecture/` as single source of truth
- **Tab System Infrastructure**: Reusable Tab and TabGroup components with flat styling
- **OBS Drawer Organization**: WebSocket and Integration tabs with consistent design
- **PSS Drawer Organization**: UDP Server & Protocol and Flag Management tabs
- **Complete Flag Management**: Full implementation with upload, search, and mapping features
- **PSS Code Mapping**: Simplified mapping where PSS codes = IOC codes
- **Flag Integration**: All systems using flags from `ui/public/assets/flags/`
- **User Experience**: Clear, intuitive interface for flag management
- **Documentation Structure**: Clean, organized documentation with no duplicates

## 🔧 Development Workflow
- **Starting Development**: `cd src-tauri && cargo tauri dev`
- **Alternative Manual Start**: 
  - Terminal 1: `cd ui && npm run start:fast`
  - Terminal 2: `cd src-tauri && cargo tauri dev`
- **Build for Production**: `cd src-tauri && cargo tauri build`
- **Cleanup**: Use `./scripts/development/cleanup-dev-environment.sh --cleanup`

## 📋 Key Features
- **Instant Video Replay**: Quick access to recent video clips
- **Event Tracking**: Real-time event capture and analysis
- **OBS Integration**: Seamless connection with OBS Studio
- **Flag Management**: Country flag recognition and display with 253+ IOC flags
- **Advanced Panel**: Comprehensive settings and diagnostics with tabbed interface
- **Tab System**: Reusable tab components with flat styling
- **PSS Protocol**: UDP-based event handling with country code mapping
- **Database Integration**: Complete PSS and UDP data storage with normalized schema

## 🎯 Next Steps
- **Immediate Priorities**: OBS Integration, Event System, Video Player
- **Future Enhancements**: AI Integration, Advanced Analytics, Multi-language Support
- **Documentation**: Keep all documentation updated and consolidated
- **Database**: Monitor performance and optimize queries as needed